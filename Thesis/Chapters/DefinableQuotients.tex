\chapter{Definable Quotients}
\label{dq}


%and sometimes we use setoids~\cite{bar:03} instead.

In \itt, the quotient type former is not necessary to define all quotients as sets.
One of the most basic examples is the set of integers $\Z$. On one hand it can be interpreted as a quotient set $\Z_0 \defeq \qset{\N\times\N}$ in which we use a pair of natural numbers $(a,b)$ to represent the integer as the result of subtraction $a-b$.  On the other hand, from the usual notation of integers, $\Z$ can be inductively defined as natural numbers together with a sign. Given any element $(a,b): \N\times\N$, there must be an element of $c : \Z$ which can be seen as the name of the equivalence class or \textbf{normal form} of $(a,b)$, thereby we can define a \textbf{normalisation function} denoted as $[\_] : \Z_0 \to \Z$.


Another example is the set of rational numbers $\Q$. Usually, rational numbers are represented as fractions, e.g.\ $\frac{1}{2}$. However different fractions can refer to the same rational numbers, e.g.\ $\frac{1}{2} = \frac{2}{4}$. It naturally gives us a quotient definition of rational numbers as \emph{fractions} (or unreduced fractions).
As we know, for one rational number, different fractions for it can always be reduced to a unique one called \emph{reduced fraction}. 
Therefore, the set $\Q$ can also be defined as a $\Sigma$-type consisting of a fraction together with a proof of the property that it is reduced. 
Thus, a normalisation function in this case is just an implementation of the reduction process.


For these quotients which are definable as a set without being treated as quotients, it seems unnecessary to interpret them as setoids. However in practice, the setoid definitions have some advantages compared to the set definition.
For example, we can define operations on $\Z$ like addition and multiplication and prove algebraic properties,
such as verifying that the structure is a ring. 
However, this is quite complicated and uses many unnecessary case
distinctions due to the cases in the set definition. E.g.\ the proving of distributivity within this setting
is not satisfactory since too many cases have to be proven from
scratch. 
In the setoid definition $\Z_0$, there is only one case and the algebraic properties are direct consequences
of the semiring structure of the natural numbers. 
For rational numbers, it is also conceivable that operations on unreduced functions are simpler to define because there is no need to make sure the result is reduced in every step.

Although the setoid definitions have some nice features in these cases, they require us to redefine all operations on sets again on setoids, for example $\text{List} (A,\sim)$.
Hence, we propose to use both the setoid
and the associated set, but to use the setoid structure to define
operations on the quotient set and to reason about it. 
The setoid definition and set definition can be related by the normalisation function so that we can lift operations and properties in the same manner as quotient types.


%define the
%the quotients via a normalisation function i.e.\ a few algebraic structures for quotients such as \emph{prequotient}, \emph{definable quotients} to encode these quotients along with application.

In this chapter we introduce the formal framework to do this, i.e.\ we provide the definition of quotients as algebraic structures specifying the normalisation function with necessary properties. Indeed, it can be seen as a ``manual construction'' of quotient types, in other words,
instead of automatically creating a type given a setoid, we
prove another given type \emph{is} the quotient.
It provides us with conversions between two representations and so combines the nice features of both representations. 


% It also means that the benefits of this framework is also  quotient types in general.
%For the reader who is interested in the code, see \Cref{app:dq}.

\section{Algebraic structures of quotients}

We first define several algebraic structures for quotients corresponding to the rules of quotient types (see \Cref{iqs}).

\begin{definition}
\textbf{Prequotient}.
\noindent
Given a setoid $(A,\sim)$,  a \emph{prequotient} over that setoid consists of
\begin{enumerate}
\item \label{enum:Q} a set $Q$,
\item \label{enum:box}a function $[\_]: A \rightarrow Q$,
\item \label{enum:sound} a proof \emph{sound} that the function $[\_]$ respects the relation $\sim$,
that is \[\sound\colon (a,b : A) \rightarrow a\sim b \rightarrow [a] = [b],\]
\end{enumerate}
\end{definition}

Roughly speaking, \ref{enum:Q} corresponds to the formation rule,
\ref{enum:box} corresponds to the introduction
rule and \ref{enum:sound} corresponds to $Q$-\textbf{Ax}. The function $[\_]$ is intended to be the \emph{normalisation}
function with respect to the equivalence relation, however it is not
enough to determine it now.


To complete a \emph{quotient}, we also need the elimination
rule and the computation rule.

\begin{definition} 
\textbf{Quotient}.
\noindent
A prequotient $(Q,[\_],\sound)$ is a quotient if we also have

\begin{enumerate}
\setcounter{enumi}{3}
\item \label{enum:elim}
for any $B: Q\rightarrow\Set$, an eliminator
 \begin{align*}
 \qelim_B\,\,:\,\,\,&(f\colon (a:A) \rightarrow B\,\class a) \\
        {\rightarrow}\, &((p:a\sim b) \rightarrow f(a) \simeq_{\sound(p)}f(b))\\
        {\rightarrow}\, &((q:Q) \rightarrow B(q))
 \end{align*}
such that $\qelimbeta : \qelim_B (f,p,\class a) = f(a)$.
\end{enumerate}
\end{definition}


This definition has a dependent eliminator.
An alternative equivalent definition given by Martin Hofmann has a
\textbf{non-dependent} eliminator and an induction principle.

\begin{definition} 
\textbf{Quotient (Hofmann's)}.
\noindent
A prequotient $(Q,[\_],\sound)$ is a quotient (Hofmann's) if we also have

\[\lift : (f : A \to B) \to (\forall a,b \to a\sim b \to f(a)
= f(b)) \to (Q \to B)\]

together with an induction principle.
Suppose B is a predicate, i.e.\ $B : Q \to \Prop$, 
\[\qind \colon((a: A)\rightarrow B (\class a))\rightarrow ((q : Q)\rightarrow B(q))\]
\end{definition}



%Such a quotient is \emph{exact}~\footnote{Exact quotient is just effective
%  quotient in \cite{maietti1999effective}} if exactly one element of
%quotient set represents one equivalence class. This property is captured by the following definition.

\begin{definition}
\textbf{Effective quotient}.
\noindent
A quotient is \emph{effective} (or exact) if we have the property that

$$\text{effective} :(\forall a,b : A) \rightarrow  \class a = \class b \rightarrow a \sim b$$
\end{definition}

We now consider a specific group of quotients which have a canonical choice in each equivalence class.

\begin{definition}\label{defquo}
 \textbf{Definable quotient}.

\noindent
Given a setoid $(A,\sim)$, a \emph{definable quotient} is a
prequotient $(Q, [\_], \sound)$ with 
\begin{align*}
\emb &: Q \rightarrow A\\
\complete &: (a : A) \rightarrow \emb [a] \sim a\\
\stable &: (q:Q) \rightarrow [\emb(q)] = q.
\end{align*}
\end{definition}

It is exactly the specification of $[\_]$ as a normalisation function with respect to $\emb$ (see \cite{DBLP:journals/jfp/AltenkirchC09}). It is also related to the choice operator for quotient types in Martin Hofmann's definition\cite{hof:95:sm}.


\begin{proposition}
All definable quotients are effective quotients.
\end{proposition}

\begin{proof}

Assume $B : \Set$, given any function $f : A \to B$ such that $p : a \sim b \to f(a) = f(b)$, define

$$\lift_B(f,p,q) \defeq f(\emb(q))$$ 

To verify the computation rule, assume $a : A$,

$$\lift_B(f,p,[a]) \equiv f(\emb([a]))$$

By completeness, we get

$$\emb([a]) \sim a$$

Then by $p : a \sim b \to f(a) = f(b)$, we can prove that


$$f(\emb([a])) = f(a)$$

For induction principle, suppose $B : Q \to \Prop$, let $f : (a : A) \to B([a])$ and $q : Q$.

By stabiliy, we get

$$[\emb(q)] = q$$

Thereby from

$$f(\emb(q)) : B([\emb(q)])$$

we can derive a proof of $B(q)$.

It follows from \Cref{elim-equiv} that this also gives rise to a quotient.


Finally, assume $[ a ] = [ b ]$ for given $a,b : A$, by completeness property, we obtain that

$$a \sim \emb [ a ] = \emb [ b ] \sim b$$

and hence $a \sim b$, i.e.\ the quotient is effective.

\end{proof}

However, a quotient is not enough to build a definable quotient because we can not extract a canonical choice for each equivalence class $q : Q$. 

The definitions of these algebraic structures and proofs about the relations between them have been encoded in Agda (see \Cref{app:dq}).

Let us investigate some examples of definable quotients.

\section{Integers}


\subsection{The setoid definition $(\Z_0, \sim)$}

Negative whole numbers can be understood as the results
of subtraction of a larger natural number from a smaller one. In fact, any integer can be seen as a result of subtraction of a natural number from another. It implies that integers can be represented by pairs of natural numbers

%integers is used to represent the results of subtraction of any natural number from another. 

$$\Z_0 \defeq \N \times \N$$

for example, from the equation $1 - 4 = - 3$, we learn that $- 3$ can be represented by $(1,4)$.

However, from the equation

$$n_1 - n_2 = n_3 - n_4,$$

it is easy to see that one integer can be represented by different pairs.

The equivalence relation can not be simply defined as this because subtraction is not closed on natural numbers. We only need to transform the equation as

$$ n_1 + n_4 = n_3 + n_2.$$

This gives rise to an equivalence relation:


$$(n_1,n_2) \sim (n_3,n_4) \defeq  n_1 + n_4 = n_3 + n_2.$$

We can easily verify that it is reflexive, symmetric and
transitive by equation transformations, so the proof is omitted here.

Thereby the setoid of integers can be formed as:

\begin{code}
\\
\>\AgdaFunction{ℤ-Setoid} \AgdaSymbol{:} \AgdaRecord{Setoid}\<%
\\
\>\AgdaFunction{ℤ-Setoid} \AgdaSymbol{=} \AgdaKeyword{record}\<%
\\
\>[2]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaSymbol{\{} \AgdaField{Carrier} \<[19]%
\>[19]\AgdaSymbol{=} \AgdaFunction{ℤ₀}\<%
\\
\>[2]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaSymbol{;} \AgdaField{\_≈\_} \<[19]%
\>[19]\AgdaSymbol{=} \AgdaPostulate{\_∼\_}\<%
\\
\>[2]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaSymbol{;} \AgdaField{isEquivalence} \AgdaSymbol{=} \AgdaPostulate{\_∼\_isEquivalence}\<%
\\
\>[2]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaSymbol{\}}\<%
\end{code}

\subsection{The set definition $\Z$}

The usual notation for an integer is a natural number with a positive
or negative sign in front: 


\begin{itemize}
\item $+\_ : \N \to \Z$
\item $-\_ : \N \to \Z$
\end{itemize}


%\begin{code}
%\\
%\>\AgdaKeyword{data} \AgdaDatatype{ℤ} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
%\\
%\>[0]\AgdaIndent{2}{}\<[2]%
%\>[2]\AgdaInductiveConstructor{+\_} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
%\\
%\>[0]\AgdaIndent{2}{}\<[2]%
%\>[2]\AgdaInductiveConstructor{-\_} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
%\end{code}

If we define $\Z$ in this way, $0$ has two intensionally different representations, which is
considered harmful because we lose canonicity and it will result in unnecessary troubles.
We can fix this problem by giving a special constructor for $0$:
\begin{itemize}
\item $+\text{suc}\_ : \N \to \Z$
\item $\text{zero} : \Z$
\item $-\text{suc}\_ : \N \to \Z$
\end{itemize}


In principle, it is preferable to use fewer constructors, because there will be fewer cases to analyse when doing pattern matching.
Taking into account the embedding of natural numbers into integers, it
makes sense to combine the positive integers with $0$:

\begin{code}%
\\
\>\AgdaKeyword{data} \AgdaDatatype{ℤ} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{+\_} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{-suc\_} \AgdaSymbol{:} \AgdaDatatype{ℕ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\>\<\end{code}

Although it is a not symmetric, we achieve both canonicity and simplicity.


\subsection{The definable quotient of integers}

The basic ingredients for the definable quotient of integers have been
given. One essential component of the quotient structure which relates
the base type and quotient type is a normalisation
function which can be recursively defined as follows:
 
\begin{code}
\>\AgdaFunction{[\_]} \<[18]%
\>[18]\AgdaSymbol{:} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\AgdaFunction{[} \AgdaBound{m} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{0} \AgdaFunction{]} \<[18]%
\>[18]\AgdaSymbol{=} \AgdaInductiveConstructor{+} \AgdaBound{m}\<%
\\
\>\AgdaFunction{[} \AgdaInductiveConstructor{0} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{suc} \AgdaBound{n} \AgdaFunction{]} \<[18]%
\>[18]\AgdaSymbol{=} \AgdaInductiveConstructor{-suc} \AgdaBound{n}\<%
\\
\>\AgdaFunction{[} \AgdaInductiveConstructor{suc} \AgdaBound{m} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{suc} \AgdaBound{n} \AgdaFunction{]} \AgdaSymbol{=} \AgdaFunction{[} \AgdaBound{m} \AgdaInductiveConstructor{,} \AgdaBound{n} \AgdaFunction{]}\<%
\end{code}

The soundness property of $\AgdaFunction{[\_]}$ can be proved by case analysis, but it turns out to be too complicated.

It is plausible define the embedding function written as $\AgdaFunction{⌜\_⌝}$.
In fact the first two cases in definition of $\AgdaFunction{[\_]}$ already gives us the answer:

\begin{code}
\\
\>\AgdaFunction{⌜\_⌝} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaFunction{ℤ₀}\<%
\\
\>\AgdaFunction{⌜} \AgdaInductiveConstructor{+} \AgdaBound{n} \AgdaFunction{⌝} \<[11]%
\>[11]\AgdaSymbol{=} \AgdaBound{n} \AgdaInductiveConstructor{,} \AgdaNumber{0}\<%
\\
\>\AgdaFunction{⌜} \AgdaInductiveConstructor{-suc} \AgdaBound{n} \AgdaFunction{⌝} \AgdaSymbol{=} \AgdaNumber{0} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{suc} \AgdaBound{n}\<%
\end{code}

To complete the definition of definable quotient, there are several
properties to prove. The stability and completeness can simply be proved by recursion. To prove soundness, we can first prove an equivalent lemma:

$$\sound' : \forall(a, b : \Z) \to \embd{a} \sim \embd{b} \to a = b$$


Given $a \sim b$, by transitivity and symmetry of $\sim$ and completeness, we can prove that


$$\embd{[a]} \sim a \sim b \sim \embd{[b]}$$

Applying the lemma $\sound'$, we get

$$[a] = [b]$$

hence $[\_]$ is \emph{sound} (it respects $\sim$).

%\begin{itemize}

%\item The stability is observable from the definitions, given any $z : \Z$, $[\embd{z}] = z$ is always holds.

%\item The completeness is not trivial. For any $z \equiv (n , 0)$ or $z \equiv (0, \suc(n))$, $\embd{[z]}$ is the same as $z$. 

%\end{itemize}

These properties have been verified in Agda (see \Cref{defQInt}), we omit the detailed proofs here.


\section{Rational numbers}

\subsection{Setoid: fractions}

In Type Theory, we usually choose fractions to represent rational numbers because the decimal expansion of a rational number can be infinite.
Any rational number can be expressed as a fraction $\frac{m}{n}$ consists of an integer
$m$ called \emph{numerator} and a non-zero integer $n$ called
\emph{denominator}.

There are different ways to interpret a fraction: two natural numbers together with a sign; two integers with a condition that the denominator is non-zero; an integer for numerator and a natural number for denominator. It is clear that the last one is the simplest,

$$\Q_0 = \Z \times \N,$$

where the sign of rational number is contained in numerator and it is easy to exclude $0$ by viewing $n$ as a denominator $n + 1$.
This means that we encode rational numbers as follows:

\begin{code}\>\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{ℚ₀} \AgdaSymbol{:} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{\_/suc\_} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{n} \AgdaSymbol{:} \AgdaDatatype{ℤ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{d} \AgdaSymbol{:} \AgdaDatatype{ℕ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{ℚ₀}\<%
\\
\>\<\end{code}

such that $2 /\text{suc}~ 2$ stands for $\frac{2}{3}$.



%The rational number represented by a fraction $\frac{m}{n}$ is indeed the result of division $m \div n$. Therefore two different fractions can represent the same rational numbers.

Different fractions can represent the same rational numbers.

$$ \frac{a}{b} = \frac{c}{d} $$

However since integers are not closed under division, we have to transform the equation into

$$a \times d = c \times b $$

in order to encode it as an equivalence relation as follows:

\begin{code}\>\<%
\\
\>\AgdaFunction{\_∼\_} \<[6]%
\>[6]\AgdaSymbol{:} \AgdaDatatype{ℚ₀} \AgdaSymbol{→} \AgdaDatatype{ℚ₀} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\\
\>\AgdaBound{n1} \AgdaInductiveConstructor{/suc} \AgdaBound{d1} \AgdaFunction{∼} \AgdaBound{n2} \AgdaInductiveConstructor{/suc} \AgdaBound{d2} \AgdaSymbol{=} \<[27]%
\>[27]\AgdaBound{n1} \AgdaFunction{ℤ*} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaInductiveConstructor{suc} \AgdaBound{d2}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaBound{n2} \AgdaFunction{ℤ*} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaInductiveConstructor{suc} \AgdaBound{d1}\AgdaSymbol{)}\<%
\\
\>\<\end{code}

\subsection{Set: reduced fractions}

A fraction $\frac{a}{b}$ is reduced if and only if $a$ and $b$ are coprime which means if their greatest common divisor is $1$. Equivalently, we can say that their absolute values are coprime, thus we can define a predicate of $\Q_0$ as

\begin{code}\>\<%
\\
\>\AgdaFunction{IsReduced} \AgdaSymbol{:} \AgdaDatatype{ℚ₀} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\\
\>\AgdaFunction{IsReduced} \AgdaSymbol{(}\AgdaBound{n} \AgdaInductiveConstructor{/suc} \AgdaBound{d}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaFunction{True} \AgdaSymbol{(}\AgdaFunction{coprime?} \AgdaFunction{∣} \AgdaBound{n} \AgdaFunction{∣} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{d}\AgdaSymbol{))}\<%
\\
\>\<\end{code}

which decides whether they are coprime or not, if it is the case, it becomes $\top$, otherwise it becomes $\bot$. Therefore, it is a propositional set (there is at most one inhabitant).

The reduced fractions are canonical representations of rational
numbers. It is a subset of fractions, so we only need to add the property above to it:

\begin{code}\>\<%
\\
\>\AgdaFunction{ℚ} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\<%
\\
\>\AgdaFunction{ℚ} \AgdaSymbol{=} \AgdaRecord{Σ[} \AgdaBound{q} \AgdaRecord{∶} \AgdaDatatype{ℚ₀} \AgdaRecord{]} \AgdaFunction{IsReduced} \AgdaBound{q}\<%
\\
\>\<\end{code}


This is equivalent to the definition of $\Q$ in Agda standard library which uses record types.


\subsection{The definable quotient of rational numbers}

The set definition $\Q$ ensures the canonicity of representations, but it complicates the manipulation
of rational numbers.

To calculate rational numbers using $\Q$, we have to reduce fractions in every step which is unnecessary from our usual experience because operations can be carried out correctly on unreduced forms.
In fact someone complained about this problem\footnote{Discussion on the Agda mailing list: http://comments.gmane.org/gmane.comp.lang.agda/6372} in practical use of unreduced fractions in Agda standard library.

Therefore a definable quotient of rational numbers consisting of both $\Q_0$ and $\Q$ and conversions between them is very useful.
We can carry out calculations and prove properties using $\Q_0$ and reduce fraction when a canonical form is required.
We believe that it can also improve the computational efficiency, even
though some people claim that the unreduced numbers can be too large to make it efficient.


We only need to implement the reduction process to be the normalisation function.

We first define an auxiliary function $\AgdaFunction{calℚ}$. It calculates a reduced fraction for a positive rational represented by a pair of natural numbers $x,y : \N$ with a condition that $y$ is not zero. 
It uses a library function $\AgdaFunction{gcd′}$ which computes the greatest common divisor $di$, the 
the new numerator $q_1$, the new denominator $q_2$ such that $q_1*di=x$, $q_2*di=y$ and $q_1$ and $q_2$ are coprime.

\begin{code}\>\<%
\\
\>\AgdaFunction{calℚ} \AgdaSymbol{:} \AgdaSymbol{∀(}\AgdaBound{x} \AgdaBound{y} \AgdaSymbol{:} \AgdaDatatype{ℕ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{y} \AgdaFunction{≢} \AgdaNumber{0} \AgdaSymbol{→} \AgdaFunction{ℚ}\<%
\\
\>\AgdaFunction{calℚ} \AgdaBound{x} \AgdaBound{y} \AgdaBound{neo} \AgdaKeyword{with} \AgdaFunction{gcd′} \AgdaBound{x} \AgdaBound{y}\<%
\\
\>\AgdaFunction{calℚ} \AgdaSymbol{.(}\AgdaBound{q₁} \AgdaPrimitive{ℕ*} \AgdaBound{di}\AgdaSymbol{)} \AgdaSymbol{.(}\AgdaBound{q₂} \AgdaPrimitive{ℕ*} \AgdaBound{di}\AgdaSymbol{)} \AgdaBound{neo} \<[33]%
\>[33]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{|} \AgdaBound{di} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{gcd-*} \AgdaBound{q₁} \AgdaBound{q₂} \AgdaBound{c} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaFunction{numr} \AgdaInductiveConstructor{/suc} \AgdaFunction{pred} \AgdaBound{q₂}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaFunction{iscoprime}\<%
\\
\>[2]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaKeyword{where}\<%
\\
\>[3]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{numr} \AgdaSymbol{=} \AgdaInductiveConstructor{+} \AgdaBound{q₁}\<%
\\
\>[3]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{deno} \AgdaSymbol{=} \AgdaInductiveConstructor{suc} \AgdaSymbol{(}\AgdaFunction{pred} \AgdaBound{q₂}\AgdaSymbol{)}\<%
\\
%
\\
\>[3]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{lzero} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{→} \AgdaBound{x} \AgdaDatatype{≡} \AgdaNumber{0} \AgdaSymbol{→} \AgdaBound{x} \AgdaPrimitive{ℕ*} \AgdaBound{y} \AgdaDatatype{≡} \AgdaNumber{0}\<%
\\
\>[3]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{lzero} \AgdaSymbol{.}\AgdaNumber{0} \AgdaBound{y} \AgdaInductiveConstructor{refl} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
%
\\
\>[3]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{q2≢0} \AgdaSymbol{:} \AgdaBound{q₂} \AgdaFunction{≢} \AgdaNumber{0}\<%
\\
\>[3]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{q2≢0} \AgdaBound{qe} \AgdaSymbol{=} \AgdaBound{neo} \AgdaSymbol{(}\AgdaFunction{lzero} \AgdaBound{q₂} \AgdaBound{di} \AgdaBound{qe}\AgdaSymbol{)}\<%
\\
%
\\
\>[3]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{invsuc} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{n} \AgdaSymbol{→} \AgdaBound{n} \AgdaFunction{≢} \AgdaNumber{0} \AgdaSymbol{→} \AgdaBound{n} \AgdaDatatype{≡} \AgdaInductiveConstructor{suc} \AgdaSymbol{(}\AgdaFunction{pred} \AgdaBound{n}\AgdaSymbol{)}\<%
\\
\>[3]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{invsuc} \AgdaInductiveConstructor{zero} \AgdaBound{nz} \AgdaKeyword{with} \AgdaBound{nz} \AgdaInductiveConstructor{refl}\<%
\\
\>[3]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaSymbol{...} \AgdaSymbol{|} \AgdaSymbol{()}\<%
\\
\>[3]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{invsuc} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaBound{nz} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>[3]\AgdaIndent{5}{}\<[5]%
\>[5]\<%
\\
\>[3]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{deno≡q2} \AgdaSymbol{:} \AgdaBound{q₂} \AgdaDatatype{≡} \AgdaFunction{deno}\<%
\\
\>[3]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{deno≡q2} \AgdaSymbol{=} \AgdaFunction{invsuc} \AgdaBound{q₂} \AgdaFunction{q2≢0}\<%
\\
%
\\
\>[3]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{copnd} \AgdaSymbol{:} \AgdaFunction{Coprime} \AgdaBound{q₁} \AgdaFunction{deno}\<%
\\
\>[3]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{copnd} \AgdaSymbol{=} \AgdaFunction{subst} \AgdaSymbol{(λ} \AgdaBound{x} \AgdaSymbol{→} \AgdaFunction{Coprime} \AgdaBound{q₁} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{deno≡q2} \AgdaBound{c}\<%
\\
%
\\
\>[3]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{witProp} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{a} \AgdaBound{b} \AgdaSymbol{→} \AgdaRecord{GCD} \AgdaBound{a} \AgdaBound{b} \AgdaNumber{1} \<[33]%
\>[33]\<%
\\
\>[5]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{→} \AgdaFunction{True} \AgdaSymbol{(}\AgdaFunction{coprime?} \AgdaBound{a} \AgdaBound{b}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{witProp} \AgdaBound{a} \AgdaBound{b} \AgdaBound{gcd1} \AgdaKeyword{with} \AgdaFunction{gcd} \AgdaBound{a} \AgdaBound{b}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{witProp} \AgdaBound{a} \AgdaBound{b} \AgdaBound{gcd1} \AgdaSymbol{|} \AgdaInductiveConstructor{zero} \AgdaInductiveConstructor{,} \AgdaBound{y} \AgdaKeyword{with} \AgdaFunction{GCD.unique} \AgdaBound{gcd1} \AgdaBound{y}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{witProp} \AgdaBound{a} \AgdaBound{b} \AgdaBound{gcd1} \AgdaSymbol{|} \AgdaInductiveConstructor{zero} \AgdaInductiveConstructor{,} \AgdaBound{y} \AgdaSymbol{|} \AgdaSymbol{()}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{witProp} \AgdaBound{a} \AgdaBound{b} \AgdaBound{gcd1} \AgdaSymbol{|} \AgdaInductiveConstructor{suc} \AgdaInductiveConstructor{zero} \AgdaInductiveConstructor{,} \AgdaBound{y} \AgdaSymbol{=} \AgdaInductiveConstructor{tt}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{witProp} \AgdaBound{a} \AgdaBound{b} \AgdaBound{gcd1} \AgdaSymbol{|} \AgdaInductiveConstructor{suc} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaBound{y} \<[40]%
\>[40]\<%
\\
\>[5]\AgdaIndent{33}{}\<[33]%
\>[33]\AgdaKeyword{with} \AgdaFunction{GCD.unique} \AgdaBound{gcd1} \AgdaBound{y}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{witProp} \AgdaBound{a} \AgdaBound{b} \AgdaBound{gcd1} \AgdaSymbol{|} \AgdaInductiveConstructor{suc} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaBound{y} \AgdaSymbol{|} \AgdaSymbol{()}\<%
\\
%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{iscoprime} \AgdaSymbol{:} \AgdaFunction{True} \AgdaSymbol{(}\AgdaFunction{coprime?} \AgdaFunction{∣} \AgdaFunction{numr} \AgdaFunction{∣} \AgdaFunction{deno}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{iscoprime} \AgdaSymbol{=} \AgdaFunction{witProp} \AgdaSymbol{\_} \AgdaSymbol{\_} \AgdaSymbol{(}\AgdaFunction{coprime-gcd} \AgdaFunction{copnd}\AgdaSymbol{)}\<%
\\
\>\<\end{code}

To apply this function to negative rational numbers, we only need to define the negation as


\begin{code}\>\<%
\\
\>\AgdaFunction{-\_} \AgdaSymbol{:} \AgdaFunction{ℚ} \AgdaSymbol{→} \AgdaFunction{ℚ}\<%
\\
\>\AgdaFunction{-\_} \AgdaSymbol{((}\AgdaBound{n} \AgdaInductiveConstructor{/suc} \AgdaBound{d}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaBound{isC}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaSymbol{((}\AgdaFunction{ℤ-} \AgdaBound{n}\AgdaSymbol{)} \AgdaInductiveConstructor{/suc} \AgdaBound{d}\AgdaSymbol{)} \AgdaInductiveConstructor{,}\<%
\\
\>[0]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaFunction{subst} \AgdaSymbol{(λ} \AgdaBound{x} \AgdaSymbol{→} \AgdaFunction{True} \AgdaSymbol{(}\AgdaFunction{coprime?} \AgdaBound{x} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{d}\AgdaSymbol{)))} \<[43]%
\>[43]\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaSymbol{(}\AgdaFunction{forgetSign} \AgdaBound{n}\AgdaSymbol{)} \AgdaBound{isC}\<%
\\
\>[0]\AgdaIndent{3}{}\<[3]%
\>[3]\AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{forgetSign} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaSymbol{→} \AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣} \AgdaDatatype{≡} \AgdaFunction{∣} \<[35]%
\>[35]\AgdaFunction{ℤ-} \AgdaBound{x} \AgdaFunction{∣}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{forgetSign} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{forgetSign} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaInductiveConstructor{zero}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>[0]\AgdaIndent{5}{}\<[5]%
\>[5]\AgdaFunction{forgetSign} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{))} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>\<\end{code}

Then it is natural to define the normalisation function as

\begin{code}\>\<%
\\
\>\AgdaFunction{[\_]} \AgdaSymbol{:} \AgdaDatatype{ℚ₀} \AgdaSymbol{→} \AgdaFunction{ℚ}\<%
\\
\>\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{n}\AgdaSymbol{)} \AgdaInductiveConstructor{/suc} \AgdaBound{d} \AgdaFunction{]} \AgdaSymbol{=} \AgdaFunction{calℚ} \AgdaBound{n} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{d}\AgdaSymbol{)} \AgdaSymbol{(λ} \AgdaSymbol{())}\<%
\\
\>\AgdaFunction{[} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaInductiveConstructor{/suc} \AgdaBound{d} \AgdaFunction{]} \AgdaSymbol{=} \AgdaFunction{-} \AgdaFunction{calℚ} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{d}\AgdaSymbol{)} \AgdaSymbol{(λ} \AgdaSymbol{())}\<%
\\
\>\<\end{code}

Because $\Q$ is just a subset of $\Q_0$, the embedding function is just the first projection of the $\Sigma$-types.

\begin{code}\>\<%
\\
\>\AgdaFunction{⌜\_⌝} \AgdaSymbol{:} \AgdaFunction{ℚ} \AgdaSymbol{→} \AgdaDatatype{ℚ₀}\<%
\\
\>\AgdaFunction{⌜\_⌝} \AgdaSymbol{=} \AgdaFunction{proj₁}\<%
\\
\>\<\end{code}

To complete the definable quotient, we have to prove all essential properties. Because of the complicated definitions, we only sketch proofs here:

\begin{itemize}
\item The soundness can be understood as the uniqueness of reduced forms which can be proved from the unique prime factorization of integers. Given the equation $a_1 * b_2 = b_1 * a_2$, we can cancel the two greatest common divisors, and the equation becomes $q_1 * r_2 = r_1 * q_2$ where $(q_1,q_2)$ and $(r_1,r_2)$ are the reduced pairs of $(a_1,a_2)$ and $(b_1,b_2)$, and both pairs are coprime. The coprime property implies that there are no common prime factors, thus we can deduce that the set of prime factors of $q_1$ is a subset of $r_1$ and vice versa, hence $q_1 = r_1$ and $q_2 = r_2$ for the same reason. In fact this has been implemented in Agda standard library for rational numbers.

\item The stability means that given a reduced fraction, if we reduce it again, it stays the same. It is the case because from the coprime property we can deduce that their greatest common divisor is $1$, thus the new numerator and denominator are the same as the old ones.

\item The completeness means that if we reduce a fraction $\frac{x}{y}$, the reduced one is equivalent to it. This is also easy to verify because in the reduction process we have the explicit proofs of $q_1*di=x$, $q_2*di=y$, to prove $q_1 * (q_2 * di) = (q_1 *di) * q_2$ we can simply cancel the greatest common divisor $di$. We ignore the sign of the fractions because it can be cancelled in those equations.
\end{itemize}


\section{The application of definable quotients}

Usually the definable quotient structure is useful when the base type (or carrier) is easier to use.  For example, compared to $\Z$, $\Z_0$ has only one pattern which leads to less case distinctions.
In  the case of rational numbers, $\Q_0$ does not have the coprime property, which also reduces complexity.
Thus we can define operators and prove properties on setoid representation. Then, we can easily lift them by two ways of conversions.

\paragraph{Operators}

We can lift a unary operator $f$ by 

$$\text{liftop1}(f) \defeq [\_] \circ f \circ \embd{\_}$$

This approach can be generalised to $n$-ary operators. An operator respects $\sim$ if


$$a \sim b \to f(a) \sim f(b)$$


It has to be noticed that this property is not required to verify before lifting.
It allows unsafe lifting but it is simpler. We can verify the properties separately. 

For integers, most of the definitions for operators on $\Z_0$ can be induced from mathematical equations. Because we can only do valid operations on natural numbers ($+$ or $*$) except $-$ which is replaced by pairing operation. For instance, to define the addition operator

$$(a_1 - b_1) + (a_2 - b_2) = (a_1 + a_2) - (b_1 + b_2)$$

provides a clear way to define it, which respects $\sim$.

\begin{code}
\\
\>\AgdaFunction{\_+\_} \AgdaSymbol{:} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaFunction{ℤ₀} \AgdaSymbol{→} \AgdaFunction{ℤ₀}\<%
\\
\>\AgdaSymbol{(}\AgdaBound{x+} \AgdaInductiveConstructor{,} \AgdaBound{x-}\AgdaSymbol{)} \AgdaFunction{+} \AgdaSymbol{(}\AgdaBound{y+} \AgdaInductiveConstructor{,} \AgdaBound{y-}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaBound{x+} \AgdaFunction{ℕ+} \AgdaBound{y+}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaSymbol{(}\AgdaBound{x-} \AgdaFunction{ℕ+} \AgdaBound{y-}\AgdaSymbol{)}\<%
\\
\end{code}

There is only one case, which means that we usually do not need to do case analysis when proving properties about additions. 
In fact, the same is true for other operators.



\paragraph{Properties}

Properties about setoids and operators defined on setoids can be lifted by using soundness of $[\_]$ and operators, completeness, stability and equivalence properties. 
For example, given a unary operator $f : A \to A$ such that $\forall (a : A) \to f (f (a)) \sim a$, we can prove that $\forall(q : Q) \to \text{liftop1}(f)(\text{liftop1}(f)(q)) = q$ as follows:

\begin{proof}
By definitional expansion, the property can be rewritten as:

$$([\_] \circ f \circ \embd{\_} \circ [\_] \circ f \circ \embd{\_})(q) = q$$

Applying the assumption $\forall (a : A) \to f (f (a)) \sim a$ on $\embd{q}$, we get

$$(f \circ f \circ \embd{\_}) (q) \sim \embd{q}$$

By completeness on $(f \circ \embd{\_}) (q)$, we can prove that

$$ (\embd{\_} \circ [\_] \circ f \circ \embd{\_}) (q) \sim  (f \circ \embd{\_}) (q) $$

Because $f$ respects $\sim$,

$$ (f \circ \embd{\_} \circ [\_] \circ  f \circ \embd{\_}) (q) \sim  (f \circ f \circ \embd{\_}) (q) $$

By transitivity of $\sim$

$$(f \circ \embd{\_} \circ [\_] \circ  f \circ \embd{\_}) (q) \sim \embd{q}$$


Because $[\_]$ respects $\sim$,


$$([\_] \circ f \circ \embd{\_} \circ [\_] \circ f \circ \embd{\_}) (q) = ([\_] \circ \embd{\_})(q)$$

Finally, by applying stability on the right hand side, we prove that


$$([\_] \circ f \circ \embd{\_} \circ [\_] \circ f \circ \embd{\_})(q) = q$$
\end{proof}


As we mentioned, one of the important motivations of definable quotients is that the setoid form is simpler and therefore properties can be proved with less case distinctions. Another advantage is that usually there are functions and properties available for the setoid form that are very useful. 

In \cite{finalyear}, the author has proved all necessary properties to form a commutative ring of integers in Agda.
In practice, for the set definition of integers, most of the basic operations and simple theorems are not unbearably complicated. However, the number of
cases grows exponentially when case analysis is unavoidable.
Although it is possible to prove lemmas which cover several cases, it is still very inefficient in general. 
We have experienced extreme difficulty in proving the distributivity law within the ring of integers.

\paragraph{Case: distributivity proof}

As an example we only discuss the left distributivity 

$$ x \times (y + z) = x \times y + x \times z$$

We use the multiplication defined in the standard library which calculates signs and absolute values separately:

\begin{code}
\\
\>\AgdaFunction{\_ℤ*\_} \AgdaSymbol{:} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaDatatype{ℤ} \AgdaSymbol{→} \AgdaDatatype{ℤ}\<%
\\
\>\AgdaBound{i} \AgdaFunction{ℤ*} \AgdaBound{j} \AgdaSymbol{=}
\AgdaFunction{sign} \AgdaBound{i} \AgdaFunction{S*}
\AgdaFunction{sign} \AgdaBound{j} \AgdaFunction{◃} \AgdaFunction{∣}
\AgdaBound{i} \AgdaFunction{∣} \AgdaPrimitive{ℕ*} \AgdaFunction{∣}
\AgdaBound{j} \AgdaFunction{∣}\<%
\\
\end{code}

If we split all cases, we will have $2 * 2 * 2$ cases in total, which is rather complicated and inconvenient.
Therefore, we decide to combine several cases.

When all of them are non-negative integers, we can apply apply the left distributivity law of natural
numbers which we assume is available. 
In fact, it can be applied in all cases in which $y$ and $z$ have the same sign, because signs can be moved out.
Thus we can write some parts of the proof (Note: $\AgdaFunction{DistributesOverˡ}$ means
that the first operator distributes over the second one):

\begin{code}
\\
\>\AgdaFunction{distˡ} \<[7]%
\>[7]\AgdaSymbol{:} \AgdaFunction{\_ℤ*\_} \AgdaFunction{DistributesOverˡ} \AgdaFunction{\_ℤ+\_}\<%
\\
\>\AgdaFunction{distˡ} \AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \AgdaKeyword{with} \AgdaFunction{sign} \AgdaBound{y} \AgdaFunction{S≟} \AgdaFunction{sign} \AgdaBound{z}\<%
\\
\>\AgdaFunction{distˡ} \AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \<[15]%
\>[15]\AgdaSymbol{|} \AgdaInductiveConstructor{yes} \AgdaBound{p} \<[23]%
\>[23]\<%
\\
\>[4]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaKeyword{rewrite} \AgdaBound{p} \<[16]%
\>[16]\<%
\\
\>[6]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{|} \AgdaFunction{lem1} \AgdaBound{y} \AgdaBound{z} \AgdaBound{p} \<[25]%
\>[25]\<%
\\
\>[6]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{|} \AgdaFunction{lem2} \AgdaBound{y} \AgdaBound{z} \AgdaBound{p} \AgdaSymbol{=} \<[27]%
\>[27]\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaFunction{trans} \AgdaSymbol{(}\AgdaFunction{cong} \AgdaSymbol{(λ} \AgdaBound{n} \AgdaSymbol{→} \AgdaFunction{sign} \AgdaBound{x} \AgdaFunction{S*} \AgdaFunction{sign} \AgdaBound{z} \AgdaFunction{◃} \AgdaBound{n}\AgdaSymbol{)} \<[47]%
\>[47]\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaFunction{ℕdistˡ} \AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣} \AgdaFunction{∣} \AgdaBound{y} \AgdaFunction{∣} \AgdaSymbol{(}\AgdaFunction{∣} \AgdaBound{z} \AgdaFunction{∣}\AgdaSymbol{)))} \<[36]%
\>[36]\<%
\\
\>[0]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaFunction{lem3} \AgdaSymbol{(}\AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣} \AgdaPrimitive{ℕ*} \AgdaFunction{∣} \AgdaBound{y} \AgdaFunction{∣}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣} \AgdaPrimitive{ℕ*} \AgdaFunction{∣} \AgdaBound{z} \AgdaFunction{∣}\AgdaSymbol{)} \AgdaSymbol{\_)}\<%
\\
\>\AgdaFunction{distˡ} \AgdaBound{x} \AgdaBound{y} \AgdaBound{z} \AgdaSymbol{|} \AgdaInductiveConstructor{no} \AgdaBound{¬p} \AgdaSymbol{=} \AgdaBound{...}\<%
\\
\end{code}
 
To prove these simpler cases we need three lemmas,

\begin{code}
\\
\>\AgdaFunction{lem1} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{sign} \AgdaBound{x} \AgdaDatatype{≡} \AgdaFunction{sign} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{ℤ+} \AgdaBound{y} \AgdaFunction{∣} \AgdaDatatype{≡} \AgdaFunction{∣} \AgdaBound{x} \AgdaFunction{∣} \AgdaPrimitive{ℕ+} \AgdaFunction{∣} \AgdaBound{y} \AgdaFunction{∣} \<[61]%
\>[61]\<%
\\
\>\AgdaFunction{lem1} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{e} \AgdaSymbol{=} \AgdaFunction{cong} \AgdaInductiveConstructor{suc} \AgdaSymbol{(}\AgdaFunction{sym} \AgdaSymbol{(}\AgdaFunction{m+1+n≡1+m+n} \AgdaBound{x} \AgdaBound{y}\AgdaSymbol{))}\<%
\\
\>\AgdaFunction{lem1} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{()}\<%
\\
\>\AgdaFunction{lem1} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{()}\<%
\\
\>\AgdaFunction{lem1} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{e} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{sign} \AgdaBound{x} \AgdaDatatype{≡} \AgdaFunction{sign} \AgdaBound{y} \AgdaSymbol{→} \AgdaFunction{sign} \AgdaSymbol{(}\AgdaBound{x} \AgdaFunction{ℤ+} \AgdaBound{y}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaFunction{sign} \AgdaBound{y}\<%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(} \AgdaInductiveConstructor{-suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{e} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{()}\<%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{-suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{()}\<%
\\
\>\AgdaFunction{lem2} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{+} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{e} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
%
\\
%
\\
\>\AgdaFunction{lem3} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{x} \AgdaBound{y} \AgdaBound{s} \AgdaSymbol{→} \AgdaBound{s} \AgdaFunction{◃} \AgdaSymbol{(}\AgdaBound{x} \AgdaPrimitive{ℕ+} \AgdaBound{y}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{x}\AgdaSymbol{)} \AgdaFunction{ℤ+} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{y}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{lem3} \AgdaInductiveConstructor{0} \AgdaInductiveConstructor{0} \AgdaBound{s} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>\AgdaFunction{lem3} \AgdaInductiveConstructor{0} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaBound{s} \AgdaSymbol{=} \AgdaFunction{sym} \AgdaSymbol{(}\AgdaFunction{ℤ-id-l} \AgdaSymbol{\_)}\<%
\\
\>\AgdaFunction{lem3} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{x}\AgdaSymbol{)} \AgdaBound{y} \AgdaBound{s} \AgdaSymbol{=} \AgdaFunction{trans} \AgdaSymbol{(}\AgdaFunction{h} \AgdaBound{s} \AgdaSymbol{(}\AgdaBound{x} \AgdaPrimitive{ℕ+} \AgdaBound{y}\AgdaSymbol{))} \AgdaSymbol{(}\<%
\\
\>[4]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaFunction{trans} \AgdaSymbol{(}\AgdaFunction{cong} \AgdaSymbol{(λ} \AgdaBound{n} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaInductiveConstructor{suc} \AgdaNumber{0}\AgdaSymbol{)} \AgdaFunction{ℤ+} \AgdaBound{n}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{lem3} \AgdaBound{x} \AgdaBound{y} \AgdaBound{s}\AgdaSymbol{))} \AgdaSymbol{(}\<%
\\
\>[4]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaFunction{trans} \AgdaSymbol{(}\AgdaFunction{sym} \AgdaSymbol{(}\AgdaPostulate{ℤ-+-assoc} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaInductiveConstructor{suc} \AgdaNumber{0}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{x}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{y}\AgdaSymbol{)))} \AgdaSymbol{(}\<%
\\
\>[4]\AgdaIndent{19}{}\<[19]%
\>[19]\AgdaFunction{cong} \AgdaSymbol{(λ} \AgdaBound{n} \AgdaSymbol{→} \AgdaBound{n} \AgdaFunction{ℤ+} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{y}\AgdaSymbol{))} \AgdaSymbol{(}\AgdaFunction{sym} \AgdaSymbol{(}\AgdaFunction{h} \AgdaBound{s} \AgdaBound{x}\AgdaSymbol{)))))}\<%
\\
\>[13]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{h} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{s} \AgdaBound{y} \AgdaSymbol{→} \AgdaBound{s} \AgdaFunction{◃} \AgdaInductiveConstructor{suc} \AgdaBound{y} \AgdaDatatype{≡} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaNumber{0}\AgdaSymbol{))} \AgdaFunction{ℤ+} \AgdaSymbol{(}\AgdaBound{s} \AgdaFunction{◃} \AgdaBound{y}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{h} \AgdaBound{s} \AgdaInductiveConstructor{0} \AgdaSymbol{=} \AgdaFunction{sym} \AgdaSymbol{(}\AgdaPostulate{ℤ-id-r} \AgdaSymbol{\_)}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{h} \AgdaInductiveConstructor{Sign.-} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaFunction{h} \AgdaInductiveConstructor{Sign.+} \AgdaSymbol{(}\AgdaInductiveConstructor{suc} \AgdaBound{y}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaInductiveConstructor{refl}\<%
\\
\end{code}


However, intuitively speaking, if $y$ and $z$ have different
signs, it is impossible to apply the left distributivity law for
natural numbers. 
There is no rule to turn $x *
(y  - z)$ into an expression which only contains natural numbers.
The case analysis is unavoidable here, and we have to prove it from scratch.
From the author's experience, this is very complicated and inefficient because we can not refer to proved theorems in a meaningful way. 

It is much simpler to prove distributivity for $Z_0$. As we have mentioned, the definitions of 
these operators only involve operators for natural
numbers. Therefore all these properties which only
involve plus, minus and multiplication, are intensional equations about natural numbers with the operators which forms a commutative semiring of natural numbers. 
We can use these laws to prove distributivity easily.

In fact with the help of the \emph{ring solver}, it can be proved automatically.
The \emph{ring solver} is an automatic equation checker for rings, e.g.\ the
ring of integers. It is implemented based on the theory described in \cite{gregoire2005proving}.

\begin{code}
\\
\>\AgdaFunction{distˡ} \AgdaSymbol{:} \<[9]%
\>[9]\AgdaFunction{\_*\_} \AgdaFunction{DistributesOverˡ} \AgdaFunction{\_+\_}\<%
\\
\>\AgdaFunction{distˡ} \AgdaSymbol{(}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{c} \AgdaInductiveConstructor{,} \AgdaBound{d}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{e} \AgdaInductiveConstructor{,} \AgdaBound{f}\AgdaSymbol{)} \AgdaSymbol{=} \AgdaFunction{solve} \AgdaNumber{6} \<[40]%
\>[40]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(λ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f} \AgdaSymbol{→} \AgdaBound{a} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{c} \AgdaFunction{:+} \AgdaBound{e}\AgdaSymbol{)} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{d} \AgdaFunction{:+} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{:+}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{d} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{c} \AgdaFunction{:+} \AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{f} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{e}\AgdaSymbol{))}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaFunction{:=}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{c} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{d} \AgdaFunction{:+} \AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaBound{e} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{:+}\<%
\\
\>[2]\AgdaIndent{6}{}\<[6]%
\>[6]\AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{d} \AgdaFunction{:+} \AgdaBound{f}\AgdaSymbol{)} \AgdaFunction{:+} \AgdaBound{b} \AgdaFunction{:*} \AgdaSymbol{(}\AgdaBound{c} \AgdaFunction{:+} \AgdaBound{e}\AgdaSymbol{)))} \AgdaInductiveConstructor{refl} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f}\<%
\\
\end{code}

It is not the simplest way to use the ring solver since we have to feed
the type (i.e.\ the equation) to the solver. In fact Agda has a feature called "reflection" which helps us to quote the type of the current goal so that the application of the ring solver can be automated. There is already some work
done by van der Walt \cite{van2012reflection}. It can be seen as an
analogy of the "ring" tactic from Coq.

To form the commutative ring of integers, we can prove all properties using the ring solver. However, the ring solver has to calculate the proof which takes a very long time to type check from our experience. As
these basic laws are used a lot in complicated theorems, pragmatically speaking, it is better not to prove them using the ring solver.
Instead, we can manually construct the proof terms to improve efficiency of library
code, sacrificing some conveniences.

Luckily, it is still much simpler than the ones for the set of integers $\Z$.
First, there is only one case of integer and as we know the equations are
indeed equations of natural numbers which can be proved using only the
properties in the commutative semiring of natural numbers. There is no
need to prove some properties for $\Z$ from scratch like in the
proof of distributivity.

\begin{code}
\\
\>\AgdaFunction{dist-lemˡ} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f} \AgdaSymbol{→} \<[28]%
\>[28]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaBound{a} \AgdaPrimitive{ℕ*} \AgdaSymbol{(}\AgdaBound{c} \AgdaPrimitive{ℕ+} \AgdaBound{e}\AgdaSymbol{)} \AgdaPrimitive{ℕ+} \AgdaBound{b} \AgdaPrimitive{ℕ*} \AgdaSymbol{(}\AgdaBound{d} \AgdaPrimitive{ℕ+} \AgdaBound{f}\AgdaSymbol{)} \AgdaDatatype{≡}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(}\AgdaBound{a} \AgdaPrimitive{ℕ*} \AgdaBound{c} \AgdaPrimitive{ℕ+} \AgdaBound{b} \AgdaPrimitive{ℕ*} \AgdaBound{d}\AgdaSymbol{)} \AgdaPrimitive{ℕ+} \AgdaSymbol{(}\AgdaBound{a} \AgdaPrimitive{ℕ*} \AgdaBound{e} \AgdaPrimitive{ℕ+} \AgdaBound{b} \AgdaPrimitive{ℕ*} \AgdaBound{f}\AgdaSymbol{)} \<[43]%
\>[43]\<%
\\
\>\AgdaFunction{dist-lemˡ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f} \AgdaSymbol{=} \AgdaFunction{trans}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(}\AgdaFunction{cong₂} \AgdaPrimitive{\_ℕ+\_} \AgdaSymbol{(}\AgdaFunction{ℕdistˡ} \AgdaBound{a} \AgdaBound{c} \AgdaBound{e}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaFunction{ℕdistˡ} \AgdaBound{b} \AgdaBound{d} \AgdaBound{f}\AgdaSymbol{))}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(}\AgdaPostulate{swap23} \AgdaSymbol{(}\AgdaBound{a} \AgdaPrimitive{ℕ*} \AgdaBound{c}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{a} \AgdaPrimitive{ℕ*} \AgdaBound{e}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{b} \AgdaPrimitive{ℕ*} \AgdaBound{d}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{b} \AgdaPrimitive{ℕ*} \AgdaBound{f}\AgdaSymbol{))}\<%
\\
%
\\
\>\AgdaFunction{distˡ} \AgdaSymbol{:} \AgdaFunction{\_ℤ₀*\_} \AgdaFunction{DistributesOverˡ} \AgdaFunction{\_ℤ₀+\_}\<%
\\
\>\AgdaFunction{distˡ} \AgdaSymbol{(}\AgdaBound{a} \AgdaInductiveConstructor{,} \AgdaBound{b}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{c} \AgdaInductiveConstructor{,} \AgdaBound{d}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{e} \AgdaInductiveConstructor{,} \AgdaBound{f}\AgdaSymbol{)} \AgdaSymbol{=} \<[32]%
\>[32]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{cong₂} \AgdaPrimitive{\_ℕ+\_} \AgdaSymbol{(}\AgdaFunction{dist-lemˡ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{c} \AgdaBound{d} \AgdaBound{e} \AgdaBound{f}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaSymbol{(}\AgdaFunction{sym} \AgdaSymbol{(}\AgdaFunction{dist-lemˡ} \AgdaBound{a} \AgdaBound{b} \AgdaBound{d} \AgdaBound{c} \AgdaBound{f} \AgdaBound{e}\AgdaSymbol{))}\<%
\\
\end{code}

We only need one special lemma which can be proved by applying distributivity
laws for natural numbers. The $\AgdaFunction{swap23}$ is a commonly
used equation rewriting lemma

$(m + n) + (p + q) = (m + p) + (n + q)$

After all, the application of the quotient structure in the integer case
provides a general approach to defining functions and prove theorems
when the base types are simpler to deal with.
When working with the field of rational numbers, we can benefit from the setoid representation. We use $\Z$ and $\N$ for the definition of $\Q$, and $\Z$ itself uses only $\N$. Therefore, any equation of rational numbers amounts to an equation of natural numbers, allowing us to apply the ring solver.

\section{Related work}

Courtieu \cite{cou:01} considers an extension of the calculus of inductive constructions (CIC), an intensional type theory, by \emph{normalized types}. 
Those can be seen as type formers for definable quotients in our sense, namely quotients which have a normalisation function. Therefore, to form a normalised type, a normalisation function is required instead of an equivalence relation. He also provides an example of integers, where the base type has three constructors $0$, $\mathsf{S}$ for successors and $\mathsf{P}$ for predecessors.


Cohen \cite{DBLP:dblp_conf/itp/Cohen13} also defines a quotient structure in Coq, which consists of $\mathsf{Q}$ as a quotient type, $\mathsf{T}$ as base type, two mapping $\mathsf{pi} : \mathsf{T} \to \mathsf{Q}$ and $\mathsf{repr} : \mathsf{Q} \to \mathsf{T}$ and a proof that $\mathsf{pi}$ is a left inverse of $\mathsf{repr}$. It is similar to our algebraic structure of definable quotients without an equivalence relation involved, $\mathsf{pi}$ corresponds to $[\_]$, $\mathsf{repr}$ corresponds to $\emb$, and the equivalence relation can be recovered simply: if for any two $s,t: \mathsf{T}$ such that $\mathsf{pi}(s) = \mathsf{pi}(t)$, then they are equivalent.

\section{Summary}

In this chapter, we have shown that, 
although we work in a theory in which quotient types are unavailable,
there are some quotients that are
themselves definable together with a normalisation function without using quotient types. 

We introduced several
algebraic structures for quotients which can be seen as ``manual construction'' of quotient types.
A \emph{prequotient} gives the basic ingredients for later
constructions. We give two equivalent definitions of \emph{quotients},
one of which has a dependent eliminator, while the other (as given by Hofmann) adds
 a non-dependent eliminator and an induction principle.
A \emph{definable quotient} includes an embedding function selecting a canonical choice for each
equivalence class such that $[\_]$ is correctly specified as a normalisation function. 
This is very useful in practice.
It provides us with a flexible conversion between setoid representations and set representations.
We can usually benefit from the convenience of the simple setoid form and auxiliary functions without losing canonicity of set representation, hence it is not necessary to redefine all kinds of functions and types on sets e.g.\ lists, on setoids again.

To show the application of definable quotients, we
used two examples, the set of integers and the set of rational
numbers. Some concrete cases have been given to show how to lift operations and theorems from setoid representations.
We illustrated the advantages of definable quotients in the comparison between $Z$ and $Z_0$, using the proof of distributivity for the commutative ring of integers.




