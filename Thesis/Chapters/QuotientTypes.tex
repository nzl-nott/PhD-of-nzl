\chapter{Quotient Types}
\label{qt}




In this chapter, we present a definition of quotient type in an \itt extended with a proof-irrelevant universe of propositions in the sense of \Cref{ittprop}. We prove that given propositional extensionality, all quotients are effective. We also explain the rules of quotient types categorically. A quotient is essentially a coequalizer or given by an adjunction with equality predicate functor \cite{Jacobs94quotientsin}. 
Quotient types in our definition are essentially quotient \emph{sets}. In \hott where types are not interpreted as sets, we discuss Voevodsky's impredicative encoding of quotient sets with all essential rules, and also quotient sets defined using higher inductive types. 

\section{Quotients in Type Theory}

\subsection{Rules for quotients}\label{iqs}

The quotient types are defined by the following rules as described in \cite{Jacobs94quotientsin,hof:95:sm}. 


\infrule[Q-\bf{Form}]
{ \Gamma \vdash A  \andalso \Gamma ,x : A , y : A \vdash x \sim y : \bf{Prop} \andalso \sim~\text{is an equivalence}}
{\Gamma \vdash \qset{A}}

Given a type $A$ with a binary equivalence relation $\sim$ on $A$, we can form the quotient $\qset{A}$. Here we use an infix notation for readability.

The equivalence properties are

\begin{itemize}
\item \textbf{Reflexivity} ref$_{\sim}$ : $\forall (a : A) \to a \sim a$
\item \textbf{Symmetry} sym$_{\sim}$ : $\forall (a,b : A) \to a \sim b \to b \sim a$
\item \textbf{Transitivity} trn$_{\sim}$ : $\forall (a,b,c : A) \to a \sim b \to \to b \sim c \to a \sim c$
\end{itemize}

\begin{remark}
Notice that the formation rule is different to Hofmann's version \cite{hof:95:sm} where $\sim$ is not required to be only equivalence relation. In fact his version is just more general which accepts non equivalence relation $R : A \to A \to \Prop$, but $A/R$ has to be understood as the quotient of $A$ by the equivalence closure of $R$.
\end{remark}

\begin{multicols}{2}
\infrule[Q-\bf{Intro}]{\Gamma \vdash a : A}{\Gamma \vdash [ a ] : \qset{A}}
\columnbreak
\infrule[Q-\bf{Ax}]
{\Gamma \vdash a , b :  A  \andalso  \Gamma \vdash  p : a \sim b}
{ \Gamma \vdash \text{Qax}(p) : [a]=_{\qset{A}} [b]}
\end{multicols}


We introduce an ``equivalence class'' for each element of $A$. It is usually denoted as $[ a ]$, or $[ a ]_{\sim}$ for $\sim$ if it is unclear which relation it refers to. 
 Qax states that the ``equivalence classes'' of two terms which are related by $\sim$ are (propositionally) equal.

 Notice that the notation of terms $[a]$ can be confused with the substitution notation like $B[a]$ or $B [a/x]$. So for a $\Pi$-type $B : (x : A) \to \Set$ and $a : A$, we write $B(a) : \Set$ for $B [a/x]$ where order of the arguments in brackets matches its definition.

% $for any possibly ambiguous occurrence, we use full notations i.e.\ $[a]_{\sim}$  for terms and $B[a/x]$ for substitution.$


In Hofmann's \cite{hof:95:sm} definition, it comes with an eliminator (also called \emph{lifting}) with a computation rule ($\beta$-rule) and an induction principle (equivalent to a $\eta$-rule): \footnote{We use shorthand notation $\hat{}$ for lifting here} 


\infrule[Q-\bf{elim}]
{\Gamma \vdash  B \andalso \Gamma \vdash f : A \to B \\
\Gamma, a: A, b : A, p : a \sim b \vdash  f^{\sim}(a,b,p) : f(a) =_{B}  f(b) \andalso \Gamma \vdash  q : \qset{A}}
{\Gamma \vdash  \hat{f}(q) : B}

\infrule[Q-\bf{comp}]{\Gamma \vdash  a : A}{\Gamma \vdash  \text{Qcomp}(a)  : \hat{f}([ a ]) = f(a) }


\infrule[Q-\bf{ind}]
{\Gamma,  x : \qset{A} \vdash P : \Prop \andalso \Gamma, a : A \vdash h(a) : P([a]) \andalso \Gamma \vdash  q : \qset{A}}
{\Gamma \vdash \text{Qind}(h,q) : P(q)}

Given a function $f : A \to B$ which respects $\sim$, we can lift it to be a function on $\qset{A}$ as $\hat{f} : \qset{A} \to B$ such that for any element $a : A$, $\hat{f}([ a ])$ computes to the same value as $f(a)$. It allows us to define functions on quotient types by functions on base types (representatives).
%Notice that \emph{function application} is written like "$f ~x ~ y$'' where $x$ and $y$ are two arguments for function $f$. 
Notice that we omit $f^=$ since the computation rule already implies that it is proof-irrelevant.

The induction principle states that for any proposition $P : \qset{A} \to \Prop$, it is enough to just consider cases $ P([ a ])$ for all $a : A$. In other words, $\qset{A}$ only consists of "equivalence classes" i.e.\ $[ a ]$.


An alternative definition in Hofmann's thesis \cite{hof:phd} includes a \emph{dependent} eliminator (dependent lifting) serves the same purpose:

\infrule[Q-\bf{dep-elim}]
{\Gamma, x : \qset{A} \vdash B \andalso \Gamma \vdash f : (a : A) \to B([ a ]) \\
\Gamma, a : A, b : A, p : a \sim b \vdash f^= (a,b,p) : f(a)
\stackrel{p}{=}  f(b) \andalso \Gamma \vdash q :
\qset{A}}
{\Gamma \vdash \hat{f}(q) : B(q)}

\infrule[Q-\bf{dep-comp}]{\Gamma \vdash a : A}
{\Gamma \vdash \text{Qdcomp} (a)  : \hat{f}([ a ]) = f(a) }


Notice that $\stackrel{p}{=}$ is an abbreviation for propositional equality which requires substitution in the type of the left hand side by $\text{Qax}(p)$ so that both sides have the same type.
We use the same notation for the two versions of eliminators because they are in fact equivalent.

\begin{proposition}\label{elim-equiv}
The \emph{non-dependent eliminator} with the \emph{induction principle} is equivalent to the \emph{dependent eliminator}.
\end{proposition}
\begin{proof}
1. Assume we have the non-dependent eliminator and the induction principle, $B$ is a dependent type on $\qset{A}$, $f$ is a dependent function of type $(a : A) \to B([ a ])$ and it respects $\sim$ under substitution (i.e.\ $f^=$), $q$ is an element of $\qset{A}$.

Set $B'$ as a dependent product $\Sigma (r : \qset{A}) ~B(r)$,

Then a non-dependent version of $f$ which has type $A \to B'$ can be defined as

$$f' (a) \defeq [ a ] , f (a)$$

Given $p : a \sim b$, we can conclude that $f'(a) =_{B'} f'(b)$ is inhabited from Qax and $f^=$.

It allows us to lift the non-dependent function $f'$ as $\hat{f'}$ such that 

\begin{equation}\label{f'comp}
\hat{f'} ([ a ]) \equiv [ a ] , f (a)
\end{equation}
Applying first projection on both sides of \ref{f'comp}, the following propositional equality is inhabited:

 $$\pi_1 (\hat{f'}([ a ])) = [ a ]$$

By induction principle, the predicate $P : \qset{A} \to \Prop$ defined as

$$P(q) \defeq \pi_1 ~(\hat{f'}(q)) =_{\qset{A}} q$$

is inhabited for all $q : \qset{A}$.

Finally, to complete the dependent eliminator, we can construct an element of type $B(q)$ by

$$\pi_2 ~(\hat{f'}(q))$$

which has the correct type because $P(q)$ holds. The computation rule is simply derivable from \ref{f'comp}.

2. It is easy to find out that the non-dependent eliminator and induction principle are just special cases of dependent eliminator.

A formalised version of this proof in Agda can be found in \Cref{app:dq}.
\end{proof}


Additionally, a quotient is effective (or exact) if an "equivalence class" only contains terms that are related by $\sim$.

\infrule[Q-\bf{effective}]
{\Gamma \vdash a :  A \andalso \Gamma \vdash b :  A  \andalso p : [a] =_{\qset{A}} [b] }
{\text{eff}(p) : a \sim b}

In fact all quotients defined with \emph{equivalence} relation are effective, if we have propositional extensionality which has been proved by Hofmann (See Section 5.1.6.4 in \cite{hof:phd}).

\begin{theorem}\label{PUEF}
With propositional extensionality, we can prove that all quotient types are effective.
\end{theorem}
\begin{proof}
%Suppose we have a set $A$ with an equivalence relation $\sim : A \to A \to \Prop$, a quotient set is $\qset{A}$.

Suppose we have a quotient type $\qset{A}$, two elements $a, b : A$ and $[ a ] = [ b ]$


Set a predicate $P_a : A \to \Prop$ as 
$$P_a (x) \defeq a \sim x$$

$P_a$ respects $\sim$ since

$x \sim y$

$\Rightarrow a \sim x \iff a \sim y$ (symmetry and transitivity)

$\equiv P_a(x) \iff P_a(y)$ (propositional extensionality)

$\Rightarrow P_a(x) = P_a(y)$

Therefore we can lift $P_a$\footnote{The elimination rule applies to large types} such that for any $x : A$

$$\hat{P} ([ x ]) \equiv a \sim x$$


We can simply deduce $\hat{P} ([ a ]) = \hat{P} ([ b ])$ from assumption $[ a ] = [ b ]$ which by definition
is just

$$a \sim a  = a \sim b$$ 

Finally with eliminator $J$ and $\text{ref}(a) : a \sim a$ we can easily prove

$$a \sim b$$.

\end{proof}

%Alternatively, we can prove it as follows:

%\begin{proof}

%Firstly we prove the equivalence relation is well-defined on the
%quotient types, namely it respects the equivalence relation:

%Suppose we have $a \sim b$ and $c \sim d$, we can deduce $a \sim c \iff
%b \sim d$. Then applying the propositional univalence axiom, we know
%that $a \sim c = b \sim d$, hence the equivalence relation is
%well-defined.

%Because it is well-defined, we can lift it such that

%$[ a ] ~\hat{\sim}~ [ b ] \equiv a \sim b$


%From reflexivity of the equivalence relation, $\forall x : A, x \sim x$, 
%we know that $\forall x : A, [x]~\hat{\sim}~[x]$.

%Assume $[a]=[b]$, using J-eliminator in $[a]~\hat{\sim}~[a]$
%(reflexivity), $[a]~\hat{\sim}~[b]$ which is definitionally equal to $a \sim b$, Hence the quotient is
%effective.
%\end{proof}

Similar to other extensional concepts like functional extensionality, simply adding quotient types into \itt as axioms can also result in \emph{non-canonical construction}.

\begin{theorem}\label{quotientcanonicity}
If we postulate the rules of quotient types, the $\N$-canonicity property is lost.
\end{theorem}

\begin{proof}
Given a type $A$ and an equivalence relation $\sim$, we postulate $\qset{A}$ exists with all the rules above.

Suppose we have two elements $a, b : A$ such that $p : a \sim b$, we have

$$\text{Qax}(p) : [a] = [b]$$

Define $B : \qset{A} \to \Set$ as

$$B(q)\defeq \N$$

We can observe that $0 : B([a])$, thus by using subst function (see \Cref{subst}), we can obtain a term of $B([b])$:

$$\mathsf{subst}(B,\text{Qax}(p),0) : B([b])$$

which is also a term of $\N$ by definition of $B$.
This term is irreducible to any numeral because $\text{Qax}(p)$ can not be reduced to the canonical term of identity type (refl). Moreover, one can not postulate propositional equality $\text{Qax}(p) = \text{refl}_{[a]}$ or $\text{Qax}(p) = \text{refl}_{[b]}$ because their types are not definitionally equal.
\end{proof}

\section{Quotients are coequalizers}

The rules of quotient types can be characterised in a category-theoretical way.

Categorically speaking, a quotient is a \textbf{coequalizer} in category $\Set$. Let us recall the definition.


\begin{definition}
\textbf{Coequalizer}.
Given two objects $X$ and $Y$ and two parallel morphisms $f, g : \morph{X}{Y}$ , a coequalizer is an object $Q$ with a morphism $q : \morph{Y}{Q}$ such that $q \circ f = q \circ g$ and it is universal: any pair $(Q' , q')$ satisfying $q' \circ f = q' \circ g$ has a unique factorisation $u$ such that $q' = u \circ q$:
\begin{displaymath}
    \xymatrix{X \ar@<0.5ex>[rr]^f \ar@<-0.5ex>[rr]_g && Y \ar[rr]^q
      \ar[ddrr]_{q'} && Q
      \ar@{.>}[dd]^u \\ \\
& &&& Q' }
\end{displaymath}
\end{definition}


Now we show that in $\Set$, assume

$$R \defeq \Sigma (a_1,a_2 : A) ~ a_1 \sim a_2$$

%$$R = \{(a_1,a_2) : A \times A ~|~ a_1 \sim a_2\}$$

and the two projections are two parallel morphisms $\pi_1,\pi_2 : \morph{R}{A}$,

A quotient corresponds to the coequalizer $(\qset{A},[\_])$:
\begin{displaymath}
    \xymatrix{R \ar@<0.5ex>[rr]^{\pi_1} \ar@<-0.5ex>[rr]_{\pi_2} && A \ar[rr]^{ [\_]}
      \ar[ddrr]_{f} && \qset{A}
      \ar@{.>}[dd]^{\hat{f}} \\ \\
& &&& B}
\end{displaymath}

The factorisation $\hat{\_}$ is just the eliminator, the computation rule and induction principle corresponds to the universal property of it. 

\begin{proposition}
The induction principle implies uniqueness, and is also derivable from the definition of coequalizer.
\end{proposition}

\begin{proof}
It is easy to see that induction principle implies the uniqueness of $\hat{f}$:

Given any $g : \qset{A} \to B$ fulfils the same property as $\hat{f}$, applying induction principle on 

$$\forall (a :A) \to g([a]) = \hat{f}([a])$$

we can deduce that $$\forall (q : \qset{A}) \to g(q) = \hat{f}(q)$$ hence $g = \hat{f}$.

The other way is more difficult:

Given $P : A \to \Prop$, $h : (x : A) \to P (x)$ define

$$P' \defeq \Sigma(x : A) ~P(x) ~\text{and}~ h'(x) = ([x],h(x))$$

we can observe that 

\begin{equation}\label{eq1}
\pi_1 \circ h' = [\_]
\end{equation}

By universal property, there is a unique $\hat{h'}$ s.t. 

\begin{equation}\label{eq2}
\hat{h'} \circ [\_] = h'
\end{equation}

By replacing \ref{eq2} in \ref{eq1}

\begin{equation}\label{eq3}
\pi_1 \circ \hat{h'} \circ [\_] = [\_]
\end{equation}

From \emph{uniqueness} we can easily prove that $[\_]$ is an \emph{epimorphism}.

%as follows:

%given $f_1,f_2 : \qset{A} \to B$ s.t. $f_1 \circ [\_] = f_2 \circ [\_]$

%Because $f_1 \circ [\_] \circ \pi_1 = f_1 \circ [\_] \circ \pi_2$ and $f_2 \circ [\_] \circ \pi_1 = f_2 \circ [\_] \circ \pi_2$ there is a unique $g : \qset{A} \to B$ such that

%$g \circ [\_] = f_1 \circ [\_] = f_2 \circ [\_]$

%Because both $f_1$ and $f_2$ fulfil this property, $f_1 = f_2$, hence $[\_]$ is epi.

Thus from \ref{eq3}, we prove that

$$\pi_1 \circ \hat{h'} = id$$

which implies that any $q : \qset{A}$, the type of $\pi_2(\hat{h'}(q))$ is

$P(\pi_1(\hat{h'}(q))) = P(q)$

as expected, hence we derive the induction principle. 
In fact, following the same procedure, a dependent eliminator is also derivable.
\end{proof}

The coequalizer (quotient) is effective if the following diagram is a \emph{pullback}

\[\xymatrix{
R\pullbackcorner\ar[rr]^{\pi_1}\ar[dd]_{\pi_2} && A\ar[dd]^{[\_]} \\ \\
A\ar[rr]_{[\_]} && Q
}\]

\begin{proof}
Assume we have two points $a, b : \textbf{1} \to A$ satisfying $[ a ] = [ b ]$.

From the pullback property, there is a unique point $r : \textbf{1} \to R$ such that

$$\pi_1(r) = a$$ and $$\pi_2(r) = b$$ 

Hence $(a, b)$ is an element of $R$, by definition it means

$$a \sim b$$
\end{proof}

In \Cref{dq}, we also introduce two other notions: prequotient and definable quotient.

Cateogorically speaking, a \emph{prequotient} is just a \emph{fork} which is just a morphism $[\_]$ such that the following diagram commutes:

\[\xymatrix{
R\ar@<0.5ex>[rr]^{\pi_0}\ar@<-0.5ex>[rr]_{\pi_1}& & A\ar[rr]^{[\_]}
& & Q
}\]

and a \emph{definable quotient} corresponds to a \emph{split coequalizer} which is a \emph{fork} with two morphisms $\emb : Q \to A$ and $t : A \to R$ such that emb chooses a representative in every equivalence class:

\begin{itemize}

\item $[\_] \circ \emb = 1_Q$

\item $\emb \circ [\_]  = \pi_0 \circ t$ and 

\item $\pi_1 \circ t = 1_A$

\end{itemize}

And we can deduce that $t(a) = (\emb [ a ] , a)$ which gives the $t$gives the proof that each element is related to the representative of its class, namely the "complete" property of definable quotients.

\section{Quotients as an adjunction}

As Jacobs \cite{Jacobs94quotientsin} suggests, quotients can be described as a left adjoint to an equality functor.

Let us recall the definition first.
\begin{definition}
\textbf{Adjunction}.
Given two categories $A$ $B$, a functor $F : A \to B$ is left adjoint
to $G : B \to A$ if we have a natural isomorphism
$\Phi : \text{hom}_{B}(F ~\_ , \_) \to hom_{A}(\_, G ~\_)$
\end{definition}


Given the category of setoids $\textbf{Setoid}$ and category of sets $\textbf{Set}$, there is an equality functor $\nabla : \textbf{Set} \to \textbf{Setoid}$ defined as
$$\nabla A \defeq (A , =_{A})$$

where the morphism part is trivial embedding.

Quotients can be seen as a functor $\textbf{Q} : \textbf{Setoid} \to \textbf{Set}$ which is
left-adjoint to a equality functor $\nabla A \defeq (A , =_{A})$

The object part of this functor corresponds to the formation rule of quotients, hence we can use $\qset{B}$
to represent $\textbf{Q} ~ (B , \sim)$.

The adjunction can be described by a natural isomorphism

$\Phi : \text{hom}_{\text{Set}}(\textbf{Q}  ~\_ , \_) \to \text{hom}_{\text{Setoid}}(\_ , \nabla ~\_)$

or a diagram for each $(Y, \sim) : \textbf{Setoid}$ and $X : \textbf{Set}$:

\begin{equation*}
\begin{aligned}
\qset{Y} & \to X \\
\midrule
\midrule
(Y, \sim) & \to (X , =_{X})
\end{aligned}
\end{equation*}

%\begin{equation*}
%\begin{aligned}
%\text{hom}_{\text{Sets}}(\qset{Y},X) \\
%\midrule
%\midrule
%\text{hom}_{\text{Setoids}}((Y, \sim), (X , =))
%\end{aligned}
%\end{equation*}


which consists of $\Phi_{(Y, \sim),X}$ and its inverse $\Phi^{-1}_{(Y, \sim),X}$ (the subscripts are omitted later).


Given an identity morphism $\text{id} : \qset{A} \to \qset{A}$, 

$$\Phi(\text{id}) : (A, \sim) \to (\qset{A}, =_{\qset{A}})$$

is just the introduction rule $[\_] : A \to \qset{A}$ with the property that it respects $\sim$.
It is also called \emph{unit} written as $\eta_{(A,\sim)}$.

Given a morphism $f : (A, \sim) \to (B , =_{B})$ which is a function that respects $\sim$,

$$\Phi^{-1}(f) : \qset{A} \to B$$ 

which corresponds to the elimination rule.

The computation rule $\hat{f} \circ [\_] \equiv f$ corresponds to the following digram in the category of setoids:


\[\xymatrix{
(A,\sim)\ar@<-0.5ex>[dd]_{\eta_{(A,\sim)}}\ar@<0.5ex>[ddrr]^{f} \\ \\
(\qset{A}, =_{\qset{A}})\ar@<-0.5ex>[rr]_{\nabla(\Phi^{-1}(f))} & & (B , =_{B})
}\]

which is commutative because

$\nabla (\Phi^{-1}(f)) \circ \eta_{(A,\sim)}$

$=\Phi(\Phi^{-1}(f))$ by adjunction law $G(f) \circ \eta_{Y} = \Phi(f)$

$=f$



We can also recover the adjunction from the definition of quotients. Define

$$\textbf{Q} ~ (Y , \sim) \defeq \qset{Y}$$

The adjunction is given by

$$\Phi(f) \defeq f \circ [\_] ~\text{and} ~ \Phi^{-1}  (g, g^{\sim}) \defeq \hat{g}$$

The computation rule and induction principle just express that these two mapping are each other inverses.

%which is compatible with $\sim$ because $[\_]$ is compatible with $\sim$.

%We can define its inverse as

%: assume $f : \qset{Y} \to X$, there is a mapping

%It is an isomorphism because it has an inverse: assume $(g, g^{\sim}) : (Y, \sim) \to (X, =_{X})$


%such that

%$\Phi^{-1} (\Phi(f))= \dlift{f \circ [\_]} = f$

%because for all $y : Y$, $\dlift{f \circ [\_]} ([ y ]) \equiv (f \circ [\_]) (y) \equiv f ([ y ])$




%where $g$ is a function compatible with $\sim$

%To prove that this is an isomorphism, assume $f : \qset{B} \to A$, there exists a mapping

%$\Omega ~ f = f \circ [\_]$ and its inverse

%$\Omega^{-1} ~ g = \hat{g}$ (we omit the property that $g$ respects $\sim$)

%The isomorphic properties can be verified as follows,

%$\Omega^{-1} (\Omega~f) = \dlift{f \circ [\_]} = f$ by the uniqueness from lifting.

%$\Omega (\Omega^{-1}~g) = \hat{g} \circ [\_] = g$ by definition of lifting.


\section{Quotients in \hott}\label{qthott}

As we mentioned before, quotient types (in the sense of \ref{iqs}) are available in \hott. Because of the different interpretations of types, it makes less confusion to call them \emph{quotients} or \emph{set quotients} here.

First, let us recall that

\begin{itemize}
\item an h-proposition (hProp) is a type $A$ which has the property $\forall(a, b : A) \to a =_{A} b$, and

\item an hSet is a type $S$ such that forall $x, y : S$, $x =_{S} y$ are h-propositions.
\end{itemize}

For simplicity, we use the term "set" for h-sets and "proposition" for
h-propositions. Note that $\Prop$ is \emph{not} the built-in universe
of propositions in Coq, but the internally defined universe of
h-propositions.

\subsection{An impredicative encoding of quotient sets}\label{impredicative}

Vladimir Voevodsky introduced an impredicative definition of quotients
which was formalised in Coq \cite{voe:hset}.

%\footnote{\url{http://www.cse.chalmers.se/~coquand/cirm.pdf}} 

%Assume we have a type $A$ (which is not necessarily a set) and an equivalence relation $\sim : A \to A \to \Prop$. 

Assume we have a set $A$ and an equivalence relation $\sim : A \to A \to \Prop$. 

\begin{definition}
An \textbf{equivalence class} is a predicate $P : A \to \Prop$ such that

it is inhabited: $\exists (a : A) ~P (a)$,

and for all $x, y : A$,

$P(x) \to P(y) \to x \sim y$ and

$P(x) \to x \sim y \to P(y)$.

These properties can be encoded as
$$\text{EqClass}(P) \defeq (\exists (a : A) ~ P (a)) \wedge (\forall (x, y : A) \to P(x) \to (x \sim y \iff P(y))).$$
\end{definition}

\begin{definition}
We define the \textbf{set quotient} as

$$\qset{A} \defeq \Sigma (P : A \to \Prop) ~ \text{EqClass}(P)$$
\end{definition}

$\qset{A}$ is a set because $A \to \Prop$ is a set and $\text{EqClass}(P)$ is a proposition. $\wedge$ is the non-dependent $\Sigma$-type for propositions and $\forall$ is the $\Pi$-type for propositions.
Because it is in fact a triple, we use $(P,p,q) : \qset{A}$ to represent an element of it for convenience, 
where $P$ is the predicate, $p$ is the truncated witness that $P$ is inhabited, and $q$ contains the proofs of the logical equivalence.
%where $P : A \to \Prop$, $p : \exists (a : A) ~ P (a)$ and $q : \forall (x, y : A) \to P(x) \to (x \sim y \iff P(y))$.

 The encoding of $\exists(a : A)~ P(a)$ is given by a truncated $\Sigma$-type: $\| \Sigma(a : A)~P(a) \|$.
The (-1)-truncation $\|-\|$ is defined \emph{impredicatively} as

$$\|X\| \defeq \forall (P : \Prop) \to (X \to P) \to P$$

with a trivial embedding function $|\_| : X \to \| X \|$:

$$| x | \defeq \lambda P ~ f \to f(x)$$

We can simply recover the elimination rule for truncation: given any function $f : X \to P$ where $P$ is a proposition, we can define a function of type $\| X \| \to P$
as 
$$\tilde{f}(x) \defeq x(P,f)$$
and $\tilde{f}(|x|) \equiv f(x)$ automatically holds.

\begin{remark}
Note that $\|X\|$ is in the universe of $\Set_1$, but with
\textbf{resizing rules} proposed by Voevodsky \cite{Universe-poly,RR},
$\|X\|$ is moved to the universe $\Set$. We can apply the resizing
rule for propositions because $\|X\|$ behaves like a proposition.  It
also has to be noticed that it is impossible to extract an element of
$A$ from a proof of $\text{EqClass}(P)$ because of the truncation.
\end{remark}

There is a canonical function $[\_] : A \to \qset{A}$ corresponding to the \textbf{introduction rule}:

$$[ a ] \defeq (\lambda x \to a \sim x, | a, \text{ref}(a) | , \lambda x~y ~p \to (\lambda q \to\text{trn}(p,q), \lambda q \to \text{trn}(\text{sym}(p),q)))$$

which respects $\sim$. The verification of compatibility requires
propositional extensionality and functional extensionality which are
available in \hott.  In fact, we can prove that $[a]$ is a unique
representation of an equivalence class.

\begin{lemma}\label{uniquerepresentation}
Given any $(P,p,q) : \qset{A}$, it is the unique representation of an equivalence class, namely

$$\forall (a : A) \to P(a) \to [a] =_{\qset{A}} (P,p,q)$$ is inhabited.
\end{lemma}
\begin{proof}

Because $\qset{A}$ is a $\Sigma$-type whose second component $\text{EqClass}(P)$ is a proposition depends on the first component, if the first components are equal, i.e.
$$\lambda b \to a \sim b = P$$
then their second components are also equal because of proof-irrelevance.

By functional extensionality, we only need to prove that
\begin{equation}\label{abpb}
\forall(b : A) \to a \sim b = P(b)
\end{equation}

Recall that the type of $q$ is $\forall(x,y : A) \to P(x) \to (x \sim y \iff (P(y)))$, from assumption $ex : P(a)$, we can prove that 


$$\forall(b : A) \to a \sim b \iff P(b)$$

Then we can simply prove \ref{abpb} by applying propositional extensionality.
Therefore

$$[a] = (P,p,q)$$ 

\end{proof}

A lifting function (non-dependent eliminator) for functions respecting
$\sim$ is also expected. Since we cannot extract a element of $A$, it
has to be defined in a more complicated way.

\begin{lemma}
Given a function $f : A \to B$ into a \emph{set} $B$ which respects $\sim$, there exists a unique function $\hat{f} = \qset{A} \to B$ such that $\hat{f} ([ a ]) \equiv f(a)$.
\end{lemma}
\begin{proof}
Assuming we have an element $(P, p, q) : \qset{A}$, we can define a
function $f_{P} : (\Sigma (x : A) ~P(x)) \to B$ simply by
$$f_{P} \defeq f \circ \pi_{1}$$
but our witness $p : \| \Sigma (x : A) ~P(x) \|$ is truncated which
cannot be applied to $f_{P}$. However we can generate a function
$$\bar{f_{P}} : \| (\Sigma (x : A) ~P(x)) \| \to B$$
applying lemma \ref{constantT}, which needs that $f_{P}$ is a constant function:

for any two elements $(x_1,p_1)$ and $(x_2,p_2)$ of type $\Sigma (x :
A) ~P(x)$, by applying the property
$$\forall(x,y : A) \to P(x) \to P(y) \to x \sim y$$
contained in $q$ to $p_1 : P(x_1)$ and $p_2 : P(x_2)$, we have that
$$x_1 \sim x_2.$$
Then because $f$ respects $\sim$,
$$f(x_1) = f(x_2).$$
By definition of $f_P$,
$$f_P(x_1,p_1) \equiv f (x_1) = f(x_2) \equiv f_P(x_2,p_2),$$
hence $f_P$ is a constant function.

To summarise, the lifting function can be defined as
$$\hat{f}(P,p,q) \defeq \bar{f_{P}}(p)$$

The \textbf{computational rule} can be verified easily:

$$\hat{f}([a]) \equiv \bar{f}_{\lambda x \to a \sim x}(|a|) \equiv f(a)$$

The \textbf{induction principle} can be generated as follows:

suppose we have $Q : \qset{A} \to \Prop$, $h : (a : A) \to Q([a])$ and
$(P,p,q) : \qset{A}$, we expect the \emph{proposition} $Q(P,p,q)$ to
hold. Since $p : \| \Sigma (a : A) ~ P(a) \|$, from the elimination
rule for truncation, we only need to construct a function of type
$$\Sigma (a : A) ~ P(a) \to Q(P,p,q).$$
Given $(a,ex) : \Sigma (a : A) ~ P(a)$, we know
$$[a] = (P,p,q)$$
from \ref{uniquerepresentation}. Thus we can substitute into $h(a) : Q([a])$ to generate a term of type $Q(P,p,q)$. Therefore we have the induction principle. The uniqueness of $\hat{f}$ is simply implied by the induction principle.
\end{proof}

The following lemma is suggested by Nicolai Kraus and can be found in
\cite{krausEscardoEtAll_existence}.

\begin{lemma}\label{constantT}
Given a constant function $g : X \to Y$ where $Y$ is a set, i.e. it satisfies
$$\forall(x,y : X) \to g(x) = g(y),$$
there exists a function $\bar{g} : \|X\| \to Y$ such that $\bar{g}(| x |) \equiv g(x)$.
\end{lemma}

\begin{proof}

Define the subset
$$Y' \defeq \Sigma (y : Y)~ \|\Sigma (x : X) ~g(x) = y \|$$
Intuitively, $Y'$ only contains the image of the constant function i.e.\ \textbf{$Y'$
is propositional}:

For any $(y_1,p_1) : Y'$ and $(y_2,p_2): Y'$, 

we can first generate the proofs 

$p_1 ((g(x) = y_1),\pi_2) : g(x) = y_1$ and 

$p_2 ((g(x) = y_2),\pi_2) : g(x) = y_2$.

By symmetry and transitivity we can prove that $y_1 = y_2$.

From the fact that a truncated type is always propositional, we can
also deduce that $p_1 = p_2$, then $(y_1,p_1) = (y_2,p_2)$. Hence we
can conclude that $Y'$ is propositional.

We can simply define a function $g' : X \to Y'$ using $g$ as
$$g'(x) \defeq (g(x), \lambda Q ~f \to f (x , \text{refl}_{=}(g(x)))).$$

Because $Y'$ is propositional, it is possible to lift $g'$ to a function $\tilde{g'} : \| X\| \to Y'$ which is defined as
$$\tilde{g'}(x) \defeq x (Y',g').$$

Finally we define
$$\bar{g} \defeq \pi_1 \circ \tilde{g'}$$
which fulfils the computation rule
$$\bar{g}(|x|) \equiv  \pi_1 (|x|(Y',g'))  \equiv \pi_1 (g' (x)) \equiv g(x).$$
\end{proof}

Furthermore, since propositional extensionality is a special case of
univalence, by \Cref{PUEF}, we can prove that the impredicative
quotients are effective.

\begin{theorem}
In \hott, the impredicative encoding of quotient sets gives rise to all the rules of quotients in the sense of \ref{iqs} including effectiveness.
\end{theorem}

\subsection{Quotient inductive types}


%As we mentioned before, quotient types (in the sense of \ref{iqs}) are available in \hott. Because of the different interpretations of types, it makes less confusion to call them \emph{quotients} here.

An alternative way to define quotients in \hott is using higher
inductive types.


Assume that $A$ is a set and $\_\sim\_ : A \to A \to \Prop$ is an
equivalence relation.  To build a quotient, we can simply impose
level-$1$ morphisms in the structure of the given set according to the
equivalence relation. Thus, a quotient $\qset{A}$ can be defined as a
higher inductive type with the following contstructors:

\begin{itemize}
\item $[\_] : A \rightarrow \qset{A}$
\item $eqv : (a,b : A) \rightarrow a \sim b \rightarrow  [a] = [b]$
\item $isSet : (x,y:\qset{A}) \rightarrow (p_1,p_2 : x = y) \rightarrow p_1 = p_2$
\end{itemize}

It is also a set so we call it \textbf{set-quotient} or
\textbf{quotient inductive types} (QITs).

%\begin{remark}
%Categorically, there is no difference between a set and a setoid because a skeleton of a setoid
%is just a discrete category which is equivalent to a set.
%\end{remark}

Some examples suggest that QITs are more powerful than quotient types.

One of the examples is the definition of real numbers $\R$ which will be discussed in \Cref{rl}. Briefly speaking, our construction of reals by Cauchy sequences of rational numbers is not Cauchy complete because not all  equivalence classes have a limit. However, the Cauchy approximation approach (see Subsection 11.3.1 in \cite{hott}) using quotient inductive types is Cauchy complete due to the fact that the equivalence relation and limits are included in its definition.

Another example is unordered trees (rooted trees) which are trees
connected to a multiset of subtrees, hence there is no ordering on
subtrees.

First we define ordered trees as:
\begin{itemize}
\item a leaf $l: \mathsf{Tree}$, or
\item an indexed family of subtrees indexed by a set $I$, $st : (I \rightarrow \mathsf{Tree}) \rightarrow \mathsf{Tree}$
\end{itemize}
with the following equivalence relation:
\begin{itemize}
\item $l_{eq} : l \sim l$,
\item $st_{eq} : (f , g : I \to \mathsf{Tree}) \to f \sim_{p} g \to st(f) \sim st(g)$,
\end{itemize}
where $f \sim_{p} g$ stands for $f$ is a permutation of $g$. The permutation can be defined using a bijective map $p : I \to I$ which relates equivalent subtrees recursively.

%However, if we use quotient type $\mathsf{Tree^{\sim}} := \qset{\mathsf{Tree}}$, the resulting trees have unordered subtrees which are themselves ordered.

If we define unordered trees as a quotient type $\mathsf{Tree^{\sim}} := \qset{\mathsf{Tree}}$, 
it is problematic to lift the constructor $st$, i.e.\ to define $\hat{st}$.
For trees with finite subtrees such as \emph{binary trees} where $I \defeq \bool$, it can be lifted by nesting lifting functions,

$$\hat{st}(a,b) = \dlift{\hat{st}(a)}(b)$$

because its type is isomorphic to $\mathsf{BTree} \rightarrow \mathsf{BTree} \rightarrow \mathsf{BTree}$.
Intuitively this approach can be applied to trees with finite subtrees. However it fails if have infinite subtrees, for example when $I \defeq \N$.

However if we use QITs to define unordered trees, we can define the
equivalence relation simultaneously with the constructors by the
higher inductive type having the following constructors:

\begin{itemize}
\item $l: \mathsf{Tree}$, 
\item $st : (I \rightarrow \mathsf{Tree}) \rightarrow \mathsf{Tree}$,

and a set of paths relating two permuted trees:

\item $l_{eq} : l  =_{\mathsf{Tree}} l$,

\item$st_{eq} : \forall (f, g : I \to \mathsf{Tree}) \rightarrow  f \sim_{p} g \rightarrow  st(f) =_{\mathsf{Tree}} st(g)$.
\end{itemize}

Thus we avoid the problem of lifting $st$ because the equivalence
relation has become the internal equality of this type.


Similarly the cumulative hierarchy of all sets introduced in
\cite{hott} (see section 10.5) suggests that quotient types have some
weaknesses compared to quotient inductive types.

A cumulative hierarchy can be given by constructors
$$\{\_\} : (I : \Set) \to (I \to M_0) \to M_0$$
along with a subset relation
$$\_\in\_ : M_0 \to M_0 \to \Prop$$
which is inhabited if $ f(i) \in \{ I , f \}$.

Then we can easily define the equivalence relation on "sets" using the
set-theoretical definition
$A \sim B \defeq \forall m : M_0, m \in A \iff m \in B.$

Similarly to unordered trees, we cannot obtain the constructor
$\dlift{\{\_\}}$ because the indexing set $I$ can be infinite.

To summarise, it seems that quotient inductive types are more powerful
than quotient types due to the ability of defining term constructors
and equivalence relations simultaneously.  However, quotient inductive
types are not available in type theories other than \hott and the
computational interpretation of them is still an open problem.
Moreover, there can be more general quotients in \hott, for example a
quotient of a type by a $1$-groupoid (See section 9.9 in
\cite{hott}). It is interesting to investigate \emph{real}
\emph{quotient types} in \hott, but it is beyond the scope of this
thesis.

\section{Related work}\label{related}

The introduction of quotient types in Type Theory has been studied by several authors in different versions of \mltt and using various approaches.

\begin{itemize}

\item In \cite{cab}, Mendler et al. considered building new types from
  a given type using a quotient operator $//$. Their work is done in
  an implementation of \ett, NuPRL.

In NuPRL, given the base type $A$ and an equivalence relation $E$, the quotient is denoted as $A//E$. Since every type comes with its own equality relation in NuPRL, the quotient operator can be
seen as a way of redefining equality for a type.

They also discuss problems that arise from defining functions on the new type which can be illustrated by a simple example:

when we want to define a function $f : (x,y) : A//E \to \bool$, it is
in fact defining a function on $A$. Assume $a, b : A$ such that
$E(a,b)$ but $f(a) \not= f(b)$. This will lead to an inconsistency
since $E(a,b)$ implies that $a$ converts to $b$ in \ett, hence the
left hand side $f(a)$ can be converted to $f(b)$, namely we get $f(b)
\not= f(b)$ which contradicts the equality reflection rule.

Therefore a function is well-defined \cite{cab} on the new type only
if it respects the equivalence relation $E$, namely

$$\forall (a,b : A) \to E(a,b) \to f(a) = f(b)$$


After the introduction of quotient types, Mendler further investigates
this topic from a categorical perspective in ~\cite{men:90}. He uses
the correspondence between quotient types in \mltt{} and coequalizers
in a category of types to define a notion called \emph{squash types},
which is further discussed by Nogin \cite{nog:02}.

\item Nogin \cite{nog:02} considers a modular approach to axiomatizing
  quotient types in NuPRL. He discusses some problems with quotient
  types. For example, since equality is extensional, we cannot recover
  the witness of equality.  He suggests including more axioms to
  conceptualise quotients. He decomposes the formalisation of a
  quotient type into several smaller primitives which are easier to
  manipulate.


\item Jacobs \cite{Jacobs94quotientsin} introduces a syntax for
  quotient types based on predicate logic within simple type
  theory. He discusses quotient types from a categorical
  perspective. In fact the syntax of quotient types arises from an
  adjunction as we mentioned before.

\item To add quotient types to \mltt, Hofmann proposes three models
  for quotient types in \cite{hof:phd}. The first one is a setoid
  model for quotient types. In this model all types are attached with
  partial equivalence relations, namely all types are partial setoids
  rather than sets. It does not provide dependency at the level of
  types but only at the level of the relations.
%This is similar to \ett in some sense but retains computational property in \itt. 
The second one is the groupoid model which supports most features
required but it is not definable in \itt.  He also proposes a third
model as an attempt to overcome problems in the previous two
models. More type dependency is provided and quotient types are
believed to be definable in this model, however it also has some
disadvantages. He also shows that \ett is conservative over \itt
extended with quotient types \cite{hof:95:con}.


\item Altenkirch \cite{alti:lics99} also provides a different setoid
  model which is built in an \itt extended with a proof-irrelevant
  universe of propositions and $\eta$-rules for $\Pi$-types and
  $\Sigma$-types. It is decidable, $\N$-canonical and permits large
  eliminations. We implemented this setoid model and interpreted
  quotient types in it (see \Cref{models}).

\item Homeier \cite{hom} axiomatises quotient types in Higher Order
  Logic (HOL) which is also a theorem prover. He creates a tool
  package to construct quotient types as a conservative extension of
  HOL so that users are able to define new types in HOL. Then he
  defines the normalisation functions and proves several properties of
  them. Finally he discusses the issues arising when quotienting on
  aggregate types such as lists and pairs.


\item Courtieu \cite{cou:01} extends of the Calculus of Inductive
  Constructions with \emph{Normalised Types} which are similar to
  quotient types, but equivalence relations are replaced by
  normalisation functions which select a canonical element for each
  equivalence class.  In fact normalised types can be seen as a proper
  subset of quotient types. We can easily recover a quotient type from
  a normalised type as below

$$a \sim b \defeq [ a ] = [ b ]$$

However not all quotient types have normal forms, for example, the set of real numbers (see \Cref{rl}).
The notion \emph{definable quotients} we proposed in \Cref{dq} is also similar to it, but does not provide a new type automatically.

\item Barthe and Geuvers \cite{bar:96} propose a new notion called
  \emph{congruence types}, which is also a special class of quotient
  types in which the base type is inductively defined and comes with a
  set of reduction rules called the term-rewriting system. The idea is
  that $\beta$-equivalence is replaced by a set of $\beta$-conversion
  rules. Congruence types can be treated as an alternative to pattern
  matching introduced in \cite{coq:92}. The main purpose of
  introducing congruence types is to solve problems in term rewriting
  systems rather than to implement quotient types.  Congruence types
  are not inductive but have good computational behaviour because we
  can use the term-rewriting system to link a term of the base type
  with a unique term of the congruence type which is its normal form.
  However this approach has some problems in termination criteria and
  interaction between rewriting systems \cite{cou:01}.

\item Barthe, Capretta and Pons \cite{bar:03} compare different ways
  of defining setoids in Type Theory.  Setoids are classified as
  partial setoids or total setoids depending on whether the equality
  relation is reflexive or not. They also consider obtaining quotients
  for different kinds of setoids, especially for partial setoids.  In
  their framework of partial setoids, suppose we have a partial setoid
  $(A,\sim)$, an element $x : A$ such that $x \sim x$ is called a
  \emph{defined} element, the others are undefined. In this case if we
  simply define a quotient by replacing the underlying partial
  equivalence relation with a new one $R$, undefined elements in the
  base setoid may be incorrectly introduced in the quotient. The
  reason is that there possibly exist some undefined elements $x : A$
  satisfying $R(x,y)$. They solve the problem by defining a restricted
  version of $R$ which only relates defined elements.


\item Abbott, Altenkirch et al. \cite{abb:04} provides the basis for
  programming with quotient datatypes polymorphically based on their
  works on containers which are datatypes whose instances are
  collections of objects, such as arrays, trees and so
  on. Generalising the notion of container, they define quotient
  containers as the containers quotiented by a collection of
  isomorphisms on the positions within the containers.

\item Voevodsky \cite{voe:hset} implements quotients in Coq based on a
  set of axioms of \hott. He first implements the notion of
  equivalence class and uses it to implement quotients which is
  analogous to the construction of quotient sets in set theory. The
  details are given in \Cref{impredicative}.
\end{itemize}





\section{Summary}

We gave the syntax of quotient types in this chapter. The underlying
relation is required to be an equivalence in our definition which is
different from \cite{hof:95:sm}. In fact, the equivalence condition
does not affect the construction of quotient types. Jacobs
\cite{Jacobs94quotientsin} has shown that, for an arbitrary relation
$R$, the same constructions can be interpreted as set theoretical
quotient sets of $A/R^{\equiv}$, where $R^{\equiv}$ is the equivalence
closure of $R$.

Two approaches of defining elimination rules were given, one having a
combination of non-dependent eliminator with an induction principle as
in Hofmann's definition and another having a dependent eliminator. We
also showed that they are equivalent.

We showed that propositional extensionality implies the effectiveness
of quotients. We characterised quotients in category theory. They do
not only correspond to coequalizers but also can be generated from a
left adjoint functor to the equality functor $\nabla : \textbf{Set}
\to \textbf{Setoid}$. We concluded with a literature review about
quotient types.






