\chapter{Syntactic $\omega$-groupoids}
\label{wog}


As we have seen in \Cref{models}, a type can be interpreted as a setoid and its equivalence proofs, i.e.  reflexivity, symmetry and transitivity, are unique. 
However in \hott, we reject the principle of uniqueness of identity proofs (UIP). 
Instead we accept the \emph{univalence axiom} proposed by Voevodsky (see \Cref{uaintro}) which says that equality of types is weakly equivalent to \emph{weak equivalence} (see \Cref{wogintro}). 
It can be viewed as a strong extensionality axiom and it does imply functional extensionality. However, adding
univalence as an axiom destroys canonicity, i.e.\ that every closed
term of type $\mathbb{N}$ is reducible to a numeral. In the special
case of extensionality and assuming a strong version of UIP Altenkirch and McBride were able to eliminate this issue
\cite{alti:lics99,alti:ott-conf} using setoids. However, it is not
clear how to generalize this in the absence of UIP to univalence which
is incompatible with UIP. To solve the problem we should generalise
the notion of setoids, namely to enrich the structure of the identity
proofs.


The generalised notion is called \emph{\wogs} (see \Cref{wogintro}) and was proposed by
Grothendieck 1983 in a famous manuscript \emph{Pursuing Stacks} \cite{gro:ps}. Maltsiniotis continued his work and suggested a simplification of the original definition which can be found in \cite{mal:gwog}. Later Ara also presents a slight variation of the simplification of {\wog} in \cite{ara:wog}. Categorically speaking an $\omega$-groupoid is an $\omega$-category in which morphisms on all levels are equivalences. As we know that a set can be seen as a discrete
category, a setoid is a category where every morphism between
any two objects is unique. A groupoid is more generalised, every morphism is
an isomorphism but the proof of isomorphism is unique, namely the
composition of a morphism with its inverse is equal to the identity. Similarly, an
$n$-groupoid is an $n$-category in which morphisms on all levels are
equivalences. {\wogs} (also called $\infty$-groupoid) is an
infinite version of $n$-groupoid. 

 To model Type Theory without UIP we
also allow the equalities to be non-strict, in other words, they are
propositional but not necessarily definitional equalities. Finally we should use {\wog} to interpret types and eliminate the univalence axiom.

There are several approaches to formalise {\wog} in Type Theory, for instance, Altenkirch and Ryp\'a\v{c}ek \cite{txa:csl}, and Brunerie's notes \cite{gb:wog}.

In this chapter, our implementation of \wog builds on the syntactic approach of
\cite{txa:csl} but simplifies it greatly following Brunerie's proposal
\cite{gb:wog} by replacing the distinct constants for each of the
higher coherence cells by a single constant $\mathsf{coh}$. In more detail, we
specify when a globular set is a {\wogs} by first defining a type
theory called {\tig} to describe the internal language of Grothendieck
{\wog}, then interpret it with a globular set and a dependent
function to it. All coherence laws of {\wog} are derivable from the
syntax, we will present some basic ones, for example reflexivity. Everything
is formalised in Agda. This is the first attempt to formalise this approach in a
dependently typed language like Agda or Coq. 
Most of the work has been published in \cite{LFMTP14} by the author, Altenkrich and  Ryp\'a\v{c}ek.

One of our main contributions is to use heterogeneous
equality for terms to overcome difficult problems encountered
when using the usual homogeneous one. We present the formalisation but
omit some complicated and less important programs, namely the
proofs of some lemmas or definitions of some auxiliary functions. For the reader who is interested in the details, you can find the complete code in \Cref{app:wog} and also online \cite{lfmtp-github}. 


\section{Syntax of weak {\Large$\omega$}-groupoids}\label{sec:syntax}
%
We develop the type theory of $\omega$-groupoids formally, following
\cite{gb:wog}. This is a type theory with only one type former which
we can view as equality type and interpret as the homset of the
$\omega$-groupoid. There are no definitional equalities, this
corresponds to the fact that we consider \emph{weak} $\omega$-groupoids. None of the groupoid laws on any levels are strict (i.e.\ definitional) but all are witnessed by
terms. Compared to \cite{txa:csl} the definition is greatly
simplified by the observation that all laws of a weak $\omega$-groupoid follow from the existence of coherence constants for
any contractible context.

In our formalisation we exploit the more liberal way to do mutual
definitions in Agda, which was implemented following up a
suggestion by the Altenkirch. It allows us to first introduce a type
former but give its definition later.

Since we are avoiding definitional equalities, we have to define a
syntactic substitution operation which we need for the general
statement of the coherence constants. However, defining these
constants requires us to prove a number of substitution laws which
with the usual definition of identity types take a very
complex mutually recursive form (see \cite{txa:csl}). We address this
issue by using heterogeneous equality \cite{mcbride:elimination}. Although 
it exploits UIP, our approach is sound because UIP holds for the
syntax. See \Cref{sec:het} for more details.

\subsection{Basic Objects}

We first declare the syntax of our type theory which is
called \tig{} namely the internal language of \wog. Since the definitions of syntactic objects involve each other, it is essential to define them in an inductive-inductive way. Agda allows us to state the types and constructors separately for involved inductive-inductive definitions. The following declarations in order are contexts as sets,
types are sets dependent on contexts, terms and variables are sets
dependent on types, context morphisms and contractible contexts.

\begin{code}\>\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{Con} \<[19]%
\>[19]\AgdaSymbol{:} \AgdaPrimitiveType{Set}\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{Ty} \AgdaSymbol{(}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaDatatype{Con}\AgdaSymbol{)} \<[19]%
\>[19]\AgdaSymbol{:} \AgdaPrimitiveType{Set}\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{Tm} \<[19]%
\>[19]\AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaDatatype{Con}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{Var} \<[19]%
\>[19]\AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaDatatype{Con}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{\_⇒\_} \<[19]%
\>[19]\AgdaSymbol{:} \AgdaDatatype{Con} \AgdaSymbol{→} \AgdaDatatype{Con} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{isContr} \<[19]%
\>[19]\AgdaSymbol{:} \AgdaDatatype{Con} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\\
\>\<\end{code}
Contexts are inductively defined as either an empty context or
a context with a type in it.

\begin{code}\>\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{Con} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{ε} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaDatatype{Con}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{\_,\_} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaDatatype{Con}\AgdaSymbol{)(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Con}\<%
\\
\>\<\end{code}
Types are defined as either $*$ which we
call $0$-cells, or a equality type between two terms of some type $A$. If the
type $A$ is an $n$-cell then we call its equality type an $(n+1)$-cell.

\begin{code}\>\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{Ty} \AgdaBound{Γ} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{*} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{\_=h\_} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{\}(}\AgdaBound{a} \AgdaBound{b} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Ty} \AgdaBound{Γ}\<%
\\
\>\<\end{code}

\subsection{Heterogeneous Equality for Terms}\label{sec:het}

One of the big challenges we encountered was the difficulty to
formalise and reason about the equalities of terms, which is
essential when defining substitution. When the usual homogeneous identity types
are used one has to use substitution to unify
the types on both sides of equality types. This results in
$\mathit{subst}$ to appear in terms, about which one has to state
substitution lemmas. This further pollutes syntax requiring lemmas
about lemmas, lemmas about lemmas about lemmas, etc. For example, we
have to prove that using $\mathit{subst}$ consecutively with two equalities
of types is propositionally equal to using $\mathit{subst}$ with the
composition of these two equalities. As the complexity of the proofs
grows more lemmas are needed. The resulting
recurrence pattern has been identified and implemented in
\cite{txa:csl} for the special cases of coherence cells for
associativity, units and interchange. However it is not clear how that
approach could be adapted to the present, much more economical
formulation of {\wog}. Moreover, the complexity brings the
Agda type checker to its limits and correctness into question.

The idea of heterogeneous equality (or JM equality) due to McBride
\cite{mcbride:elimination} used to resolve this issue is to define
equality for terms of different types, but its inhabitants only for
terms of definitionally equal types. However, the corresponding
elimination principle relies on UIP.  In \itt, UIP is not provable
in general, namely not all types are h-sets (homotopy
0-types). However every type with decidable equality is an h-set.
Inductive types with finitary constructors have decidable equality. In
our case, the types which stand for syntactic objects (contexts,
types, terms) are all inductive-inductive types with finitary
constructors. It follows by Hedberg's Theorem \cite{hed:98} that any
type with decidable equality satisfies UIP and it therefore follows
that the syntax satisfies UIP. Because, the equality of syntactic
types is unique, it is safe to use heterogeneous equality and proceed
without using substitution lemmas which would otherwise be necessary
to match terms of different types. From a computational perspective,
it means that every equality of types can be reduced to
$\mathit{refl}$ and using $\mathit{subst}$ to construct terms is
proof-irrelevant, which is expressed in the following definition of
heterogeneous equality for terms.


\begin{code}\>\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{\_≅\_} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaDatatype{Con}\AgdaSymbol{\}\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{\}} \AgdaSymbol{:}\<%
\\
\>[2]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{\{}\AgdaBound{B} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaBound{B} \AgdaSymbol{→} \AgdaPrimitiveType{Set} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{refl} \AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{b} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{b} \AgdaDatatype{≅} \AgdaBound{b}\<%
\\
\>\<\end{code}
Once we have heterogeneous equality for terms, we can define a proof-irrelevant substitution which we call \emph{coercion} since it gives us a term of type $A$ if we have a term of type $B$ and the
two types are equal. We can also prove that the coerced term is heterogeneously equal to the
original term. Combining these definitions, it is much
more convenient to formalise and reason about term equations.

\begin{code}\>\<%
\\
\>\AgdaFunction{\_⟦\_⟫} \<[12]%
\>[12]\AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaDatatype{Con}\AgdaSymbol{\}\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{\}(}\AgdaBound{a} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaBound{B}\AgdaSymbol{)} \<[46]%
\>[46]\<%
\\
\>[0]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{→} \AgdaBound{A} \AgdaDatatype{≡} \AgdaBound{B} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaBound{A}\<%
\\
\>\AgdaBound{a} \AgdaFunction{⟦} \AgdaInductiveConstructor{refl} \AgdaFunction{⟫} \<[12]%
\>[12]\AgdaSymbol{=} \AgdaBound{a}\<%
\\
%
\\
\>\AgdaFunction{cohOp} \<[12]%
\>[12]\AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaDatatype{Con}\AgdaSymbol{\}\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{\}\{}\AgdaBound{a} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaBound{B}\AgdaSymbol{\}(}\AgdaBound{p} \AgdaSymbol{:} \AgdaBound{A} \AgdaDatatype{≡} \AgdaBound{B}\AgdaSymbol{)} \<[57]%
\>[57]\<%
\\
\>[0]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{→} \AgdaBound{a} \AgdaFunction{⟦} \AgdaBound{p} \AgdaFunction{⟫} \AgdaDatatype{≅} \AgdaBound{a}\<%
\\
\>\AgdaFunction{cohOp} \AgdaInductiveConstructor{refl} \<[12]%
\>[12]\AgdaSymbol{=} \AgdaInductiveConstructor{refl} \AgdaSymbol{\_}\<%
\\
\>\<\end{code}

\subsection{Substitutions}

In this chapter we usually define a set of functions together and
we name a function $\mathsf{x}$ as $\mathsf{xC}$ for contexts, $\mathsf{xT}$ for types, $\mathsf{xV}$ for
variables $\mathsf{xtm}$ for terms and $\mathsf{xS}$ for context morphisms (substitutions) as conventions. For example
the substitutions are declared as follows:

\begin{code}\>\<%
\\
\>\AgdaFunction{\_[\_]T} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Ty} \AgdaBound{Δ} \AgdaSymbol{→} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ} \AgdaSymbol{→} \AgdaDatatype{Ty} \AgdaBound{Γ}\<%
\\
\>\AgdaFunction{\_[\_]V} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ} \AgdaBound{A}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Var} \AgdaBound{A} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]T}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{\_[\_]tm} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ} \AgdaBound{A}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaBound{A} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]T}\AgdaSymbol{)} \<[59]%
\>[59]\<%
\\
\>\<\end{code}
Indeed, compositions of context morphisms can be understood as substitutions for context morphisms as well.

\begin{code}\>\<%
\\
\>\AgdaFunction{\_⊚\_} \AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ} \AgdaBound{Θ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{Δ} \AgdaDatatype{⇒} \AgdaBound{Θ} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Θ} \<[47]%
\>[47]\<%
\\
\>\<\end{code}
Context morphisms are defined inductively similarly to contexts. A context morphism is a list of terms corresponding to the list of types in the context on the right hand side of the morphism.

\begin{code}\>\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{\_⇒\_} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{•} \<[7]%
\>[7]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaInductiveConstructor{ε}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{\_,\_} \<[7]%
\>[7]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ}\AgdaSymbol{\}(}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{)\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Δ}\AgdaSymbol{\}(}\AgdaBound{a} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]T}\AgdaSymbol{))}\<%
\\
\>[2]\AgdaIndent{7}{}\<[7]%
\>[7]\AgdaSymbol{→} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaSymbol{(}\AgdaBound{Δ} \AgdaInductiveConstructor{,} \AgdaBound{A}\AgdaSymbol{)}\<%
\\
\>\<\end{code}

\subsection{Weakening}

We can freely add types to the contexts of any given type judgements,
term judgements or context morphisms. These are the weakening rules.

\begin{code}\>\>[2]\AgdaIndent{3}{}\<[3]%
\>[3]\<%
\\
\>\AgdaFunction{\_+T\_} \<[7]%
\>[7]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)(}\AgdaBound{B} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Ty} \AgdaSymbol{(}\AgdaBound{Γ} \AgdaInductiveConstructor{,} \AgdaBound{B}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{\_+tm\_} \<[7]%
\>[7]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{A}\AgdaSymbol{\}(}\AgdaBound{a} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaBound{A}\AgdaSymbol{)(}\AgdaBound{B} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{+T} \AgdaBound{B}\AgdaSymbol{)} \<[52]%
\>[52]\<%
\\
\>\AgdaFunction{\_+S\_} \<[7]%
\>[7]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ}\AgdaSymbol{\}(}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{)(}\AgdaBound{B} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{Γ} \AgdaInductiveConstructor{,} \AgdaBound{B}\AgdaSymbol{)} \AgdaDatatype{⇒} \AgdaBound{Δ} \<[53]%
\>[53]\<%
\\
\>\<\end{code}

\subsection{Terms}

A term can be either a variable or a coherence constant ($\AgdaInductiveConstructor{coh}$).

We first define variables separately using the weakening rules. We
use typed de Bruijn indices to define variables as either the rightmost
variable of the context, or some variable in the context which can be
found by cancelling the rightmost variable along with each $\AgdaInductiveConstructor{vS}$.

\begin{code}\>\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{Var} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{v0} \AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{\}} \<[35]%
\>[35]\AgdaSymbol{→} \AgdaDatatype{Var} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{+T} \AgdaBound{A}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{vS} \AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}\{}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{\}(}\AgdaBound{x} \AgdaSymbol{:} \AgdaDatatype{Var} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Var} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{+T} \AgdaBound{B}\AgdaSymbol{)}\<%
\\
\>\<\end{code}

The coherence constants are the most crucial topic in $wog$. In this syntactic approach, they are primitive terms of the primitive types in \emph{contractible contexts}
which will be introduced below. Indeed it encodes the fact that any type in a contractible context is inhabited, and so are the types generated by substituting into a contractible context.

\begin{code}\>\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{Tm} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{var} \<[7]%
\>[7]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Var} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaBound{A}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{coh} \<[7]%
\>[7]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{isContr} \AgdaBound{Δ} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{)} \<[42]%
\>[42]\<%
\\
\>[2]\AgdaIndent{7}{}\<[7]%
\>[7]\AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Δ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]T}\AgdaSymbol{)}\<%
\\
\>\<\end{code}

\subsection{Contractible contexts}
With variables defined, it is possible to formalise another core part of the syntactic framework, \emph{contractible
contexts}. Intuitively speaking, a context is contractible if its geometric
realization is contractible to a point. It either contains one
variable of the type $*$ which is the base case, or we can extend a contractible context with a
variable of an existing type and an $n$-cell, namely a morphism,
between the new variable and some existing variable. Contractibility
of contexts is defined as follows:

\begin{code}\>\<%
\\
\>\AgdaKeyword{data} \AgdaDatatype{isContr} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{c*} \<[7]%
\>[7]\AgdaSymbol{:} \AgdaDatatype{isContr} \AgdaSymbol{(}\AgdaInductiveConstructor{ε} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{*}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{ext} \<[7]%
\>[7]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{isContr} \AgdaBound{Γ} \AgdaSymbol{→} \AgdaSymbol{\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{\}(}\AgdaBound{x} \AgdaSymbol{:} \AgdaDatatype{Var} \AgdaBound{A}\AgdaSymbol{)} \<[50]%
\>[50]\<%
\\
\>[2]\AgdaIndent{7}{}\<[7]%
\>[7]\AgdaSymbol{→} \AgdaDatatype{isContr} \AgdaSymbol{(}\AgdaBound{Γ} \AgdaInductiveConstructor{,} \AgdaBound{A} \AgdaInductiveConstructor{,} \AgdaSymbol{(}\AgdaInductiveConstructor{var} \AgdaSymbol{(}\AgdaInductiveConstructor{vS} \AgdaBound{x}\AgdaSymbol{)} \AgdaInductiveConstructor{=h} \AgdaInductiveConstructor{var} \AgdaInductiveConstructor{v0}\AgdaSymbol{))} \<[54]%
\>[54]\<%
\\
\>\<\end{code}

\subsection{Lemmas}

Since contexts, types, variables and
terms are all mutually defined, most of their properties have to
be proved simultaneously as well. Note that we are free to define all the
types first and all the definitions (not shown) later. 

The following lemmas are essential for the constructions and theorem
proving later.  The first set of lemmas states that to substitute a
type, a variable, a term, or a context morphism with two context
morphisms consecutively, is equivalent to substitute with the
composition of the two context morphisms:

\begin{code}\>\<%
\\
\>\AgdaFunction{[⊚]T} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ} \AgdaBound{Θ} \AgdaBound{A}\AgdaSymbol{\}\{}\AgdaBound{θ} \AgdaSymbol{:} \AgdaBound{Δ} \AgdaDatatype{⇒} \AgdaBound{Θ}\AgdaSymbol{\}\{}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{\}} \<[43]%
\>[43]\<%
\\
\>[0]\AgdaIndent{8}{}\<[8]%
\>[8]\AgdaSymbol{→} \AgdaBound{A} \AgdaFunction{[} \AgdaBound{θ} \AgdaFunction{⊚} \AgdaBound{δ} \AgdaFunction{]T} \AgdaDatatype{≡} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{[} \AgdaBound{θ} \AgdaFunction{]T}\AgdaSymbol{)}\AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]T} \<[43]%
\>[43]\<%
\\
%
\\
\>\AgdaFunction{[⊚]v} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ} \AgdaBound{Θ} \AgdaBound{A}\AgdaSymbol{\}(}\AgdaBound{x} \AgdaSymbol{:} \AgdaDatatype{Var} \AgdaBound{A}\AgdaSymbol{)\{}\AgdaBound{θ} \AgdaSymbol{:} \AgdaBound{Δ} \AgdaDatatype{⇒} \AgdaBound{Θ}\AgdaSymbol{\}\{}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{8}{}\<[8]%
\>[8]\AgdaSymbol{→} \AgdaBound{x} \AgdaFunction{[} \AgdaBound{θ} \AgdaFunction{⊚} \AgdaBound{δ} \AgdaFunction{]V} \AgdaDatatype{≅} \AgdaSymbol{(}\AgdaBound{x} \AgdaFunction{[} \AgdaBound{θ} \AgdaFunction{]V}\AgdaSymbol{)} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]tm}\<%
\\
%
\\
\>\AgdaFunction{[⊚]tm} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ} \AgdaBound{Θ} \AgdaBound{A}\AgdaSymbol{\}(}\AgdaBound{a} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaBound{A}\AgdaSymbol{)\{}\AgdaBound{θ} \AgdaSymbol{:} \AgdaBound{Δ} \AgdaDatatype{⇒} \AgdaBound{Θ}\AgdaSymbol{\}\{}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{8}{}\<[8]%
\>[8]\AgdaSymbol{→} \AgdaBound{a} \AgdaFunction{[} \AgdaBound{θ} \AgdaFunction{⊚} \AgdaBound{δ} \AgdaFunction{]tm} \AgdaDatatype{≅} \AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{[} \AgdaBound{θ} \AgdaFunction{]tm}\AgdaSymbol{)} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]tm}\<%
\\
%
\\
\>\AgdaFunction{⊚assoc} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ} \AgdaBound{Θ} \AgdaBound{Ω}\AgdaSymbol{\}(}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{Θ} \AgdaDatatype{⇒} \AgdaBound{Ω}\AgdaSymbol{)\{}\AgdaBound{θ} \AgdaSymbol{:} \AgdaBound{Δ} \AgdaDatatype{⇒} \AgdaBound{Θ}\AgdaSymbol{\}\{}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{\}} \<[55]%
\>[55]\<%
\\
\>[0]\AgdaIndent{8}{}\<[8]%
\>[8]\AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{γ} \AgdaFunction{⊚} \AgdaBound{θ}\AgdaSymbol{)} \AgdaFunction{⊚} \AgdaBound{δ} \AgdaDatatype{≡} \AgdaBound{γ} \AgdaFunction{⊚} \AgdaSymbol{(}\AgdaBound{θ} \AgdaFunction{⊚} \AgdaBound{δ}\AgdaSymbol{)} \<[37]%
\>[37]\<%
\\
\>\<\end{code}
The second set states that weakening inside substitution is equivalent to weakening outside:

\begin{code}\>\<%
\\
\>\AgdaFunction{[+S]T} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ} \AgdaBound{A} \AgdaBound{B}\AgdaSymbol{\}\{}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{8}{}\<[8]%
\>[8]\AgdaSymbol{→} \AgdaBound{A} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{+S} \AgdaBound{B} \AgdaFunction{]T} \AgdaDatatype{≡} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]T}\AgdaSymbol{)} \AgdaFunction{+T} \AgdaBound{B} \<[42]%
\>[42]\<%
\\
%
\\
\>\AgdaFunction{[+S]tm} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ} \AgdaBound{A} \AgdaBound{B}\AgdaSymbol{\}(}\AgdaBound{a} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaBound{A}\AgdaSymbol{)\{}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{8}{}\<[8]%
\>[8]\AgdaSymbol{→} \AgdaBound{a} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{+S} \AgdaBound{B} \AgdaFunction{]tm} \AgdaDatatype{≅} \AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]tm}\AgdaSymbol{)} \AgdaFunction{+tm} \AgdaBound{B}\<%
\\
%
\\
\>\AgdaFunction{[+S]S} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ} \AgdaBound{Θ} \AgdaBound{B}\AgdaSymbol{\}\{}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Δ} \AgdaDatatype{⇒} \AgdaBound{Θ}\AgdaSymbol{\}\{}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{8}{}\<[8]%
\>[8]\AgdaSymbol{→} \AgdaBound{δ} \AgdaFunction{⊚} \AgdaSymbol{(}\AgdaBound{γ} \AgdaFunction{+S} \AgdaBound{B}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaSymbol{(}\AgdaBound{δ} \AgdaFunction{⊚} \AgdaBound{γ}\AgdaSymbol{)} \AgdaFunction{+S} \AgdaBound{B}\<%
\\
\>\<\end{code}
We can cancel the last term in the substitution for weakened objects
since weakening doesn't introduce new variables in types and terms.

\begin{code}\>\<%
\\
\>\AgdaFunction{+T[,]T} \<[10]%
\>[10]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ} \AgdaBound{A} \AgdaBound{B}\AgdaSymbol{\}\{}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{\}\{}\AgdaBound{b} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaSymbol{(}\AgdaBound{B} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]T}\AgdaSymbol{)\}} \<[53]%
\>[53]\<%
\\
\>[-6]\AgdaIndent{10}{}\<[10]%
\>[10]\AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{+T} \AgdaBound{B}\AgdaSymbol{)} \AgdaFunction{[} \AgdaBound{δ} \AgdaInductiveConstructor{,} \AgdaBound{b} \AgdaFunction{]T} \AgdaDatatype{≡} \AgdaBound{A} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]T}\<%
\\
%
\\
\>\AgdaFunction{+tm[,]tm} \<[10]%
\>[10]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ} \AgdaBound{A} \AgdaBound{B}\AgdaSymbol{\}\{}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{\}\{}\AgdaBound{c} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaSymbol{(}\AgdaBound{B} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]T}\AgdaSymbol{)\}}\<%
\\
\>[0]\AgdaIndent{10}{}\<[10]%
\>[10]\AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{a} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaBound{A}\AgdaSymbol{)} \<[23]%
\>[23]\<%
\\
\>[0]\AgdaIndent{10}{}\<[10]%
\>[10]\AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{+tm} \AgdaBound{B}\AgdaSymbol{)} \AgdaFunction{[} \AgdaBound{δ} \AgdaInductiveConstructor{,} \AgdaBound{c} \AgdaFunction{]tm} \AgdaDatatype{≅} \AgdaBound{a} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]tm} \<[46]%
\>[46]\<%
\\
\>\<\end{code}
Most of the substitutions are defined as usual, except the one for coherence constants. In this case, we substitute in the context morphism part and one of the lemmas declared above is used.

\begin{code}\>\<%
\\
\>\AgdaInductiveConstructor{var} \AgdaBound{x} \<[12]%
\>[12]\AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]tm} \AgdaSymbol{=} \AgdaBound{x} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]V}\<%
\\
\>\AgdaInductiveConstructor{coh} \AgdaBound{cΔ} \AgdaBound{γ} \AgdaBound{A} \<[12]%
\>[12]\AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]tm} \AgdaSymbol{=} \AgdaInductiveConstructor{coh} \AgdaBound{cΔ} \AgdaSymbol{(}\AgdaBound{γ} \AgdaFunction{⊚} \AgdaBound{δ}\AgdaSymbol{)} \AgdaBound{A} \AgdaFunction{⟦} \AgdaFunction{sym} \AgdaFunction{[⊚]T} \AgdaFunction{⟫}\<%
\\
\>\<\end{code}


\section{Some Important Derivable Constructions}

In this section we show how to reconstruct the structure
of a (weak) $\omega$-groupoid from the syntactical framework presented
in \Cref{sec:syntax} in the more explicit style of \cite{txa:csl}. To 
this end, let us call a term $a : \Tm~\AgdaBound{A}$ an $n$-cell if
$\AgdaFunction{level}~\AgdaBound{A}~ \AgdaSymbol{\equiv}~ \AgdaBound{n}$, where 

\begin{code}\>\<%
\\
\>\AgdaFunction{level} \<[22]%
\>[22]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Ty} \AgdaBound{Γ} \AgdaSymbol{→} \AgdaDatatype{ℕ}\<%
\\
\>\AgdaFunction{level} \AgdaInductiveConstructor{*} \<[22]%
\>[22]\AgdaSymbol{=} \AgdaNumber{0}\<%
\\
\>\AgdaFunction{level} \AgdaSymbol{(}\AgdaInductiveConstructor{\_=h\_} \AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}} \AgdaSymbol{\_} \AgdaSymbol{\_)} \<[22]%
\>[22]\AgdaSymbol{=} \AgdaInductiveConstructor{suc} \AgdaSymbol{(}\AgdaFunction{level} \AgdaBound{A}\AgdaSymbol{)} \<[38]%
\>[38]\<%
\\
\>\<\end{code}
In any $\omega$-category, any $n$-cell $a$ has a  domain (source), $s^n_m\,a$, and
a codomain (target), $t^n_m\,a$, for each $m \le n$. These are, of
course, $(n \text{-} m)$-cells. For each pair of $n$-cells such that for some
$m$, $s^n_m a \equiv t^n_m b$, there must exist their composition
${a \circ^n_m b}$ which is an $n$-cell. Composition is (weakly)
associative. Moreover for any $(n \text{-} m)$-cell $\AgdaBound{x}$ there
exists an $n$-cell $\mathsf{id}^n_m\,\AgdaBound{x}$ which
behaves like a (weak) identity with respect to $\circ^n_m$.
For the time being we discuss only the construction of cells and omit
the question of coherence. 

For instance, in the simple case of bicategories, each $2$-cell $a$ has a
horizontal source $s^1_1\,a$ and target $t^1_1\,a$, and also a vertical source
$s^2_1\,a$ and target $t^2_1 a$,
which is also the source and target, of the horizontal source and target,
respectively, of $a$. There is horizontal composition of $1$-cells $\circ^1_1$: $x
\to^f y \to^g z$, and also horizontal composition of $2$-cells
$\circ^2_1$, and vertical composition of $2$-cells $\circ^2_2$. There
is a horizontal identity on $a$, $\mathsf{id}^1_1\,a$, and vertical
identity on $a$, $\mathsf{id}^2_1\,a =
\mathsf{id}^2_2\mathsf{id}^1_1\,a$. 

Thus each $\omega$-groupoid construction is defined with respect to a
\emph{level}, $m$, and depth $n \text{-} m$ and the structure of
an $\omega$-groupoid is repeated on each level. As we are working purely syntactically we
may make use of this fact and define all groupoid structure only at level
$m=1$ and provide a so-called \emph{replacement operation} which allows us to lift
any cell to an arbitrary type $A$. It is called 'replacement' because
we are syntactically replacing the base type $*$ with an arbitrary
type, $A$.

An important general mechanism we rely on throughout the development
follows directly from the type of the only non-trivial constructor of $\Tm$,
$\mathsf{coh}$, which tells us that to construct a
new term of type $\Gamma \vdash A$, we need a contractible context,
$\Delta$, a type $\Delta\vdash T$ and a context morphism $\delta :
\Gamma \Rightarrow \Delta$ such that
%
\[
\AgdaBound{T} \,\AgdaFunction{[}\, \AgdaBound{δ}\,
\AgdaFunction{]T}~\AgdaDatatype{≡}~\AgdaBound{A}
\]
%
Because in a contractible context all types are inhabited we may in a
way work freely in $\Delta$ and then pull back all terms to $A$ using
$\delta$. 
To show this formally, we must first define identity context morphisms
which complete the definition of a \emph{category} of contexts and
context morphisms:

\begin{code}\>\<%
\\
\>\AgdaFunction{IdS} \AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Γ}\<%
\\
\>\<\end{code}
It satisfies the following property:

\begin{code}\>\<%
\\
\>\AgdaFunction{IC-T} \AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{A} \AgdaFunction{[} \AgdaFunction{IdS} \AgdaFunction{]T} \AgdaDatatype{≡} \AgdaBound{A}\<%
\\
\>\<\end{code}
The definition proceeds by structural recursion and therefore extends
to terms, variables and context morphisms with analogous properties. 
It allows us to define at once:

\begin{code}\>\<%
\\
\>\AgdaFunction{Coh-Contr} \<[15]%
\>[15]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{isContr} \AgdaBound{Γ} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaBound{A}\<%
\\
\>\AgdaFunction{Coh-Contr} \AgdaBound{isC} \<[15]%
\>[15]\AgdaSymbol{=} \AgdaInductiveConstructor{coh} \AgdaBound{isC} \AgdaFunction{IdS} \AgdaSymbol{\_} \AgdaFunction{⟦} \AgdaFunction{sym} \AgdaFunction{IC-T} \AgdaFunction{⟫}\<%
\\
\>\<\end{code}
We use $\AgdaFunction{Coh-Contr}$ as follows: for each kind of cell we
want to define, we construct a minimal contractible context built out
of variables together with a context morphism that populates the
context with terms and a lemma that states an equality
between the substitution and the original type.


\subsection{Suspension and Replacement}
\label{sec:susp-and-repl}
%
For an arbitrary type $A$ in $\Gamma$ of level $n$ one can
define a context with $2n$
variables, called the \emph{stalk} of $A$. Moreover one can
define a morphism from $\Gamma$ to the stalk of $A$ such that its
substitution into the maximal type in the stalk of $A$ gives back
$A$. The stalk of $A$ depends only on the level of $A$, the terms in
$A$ define the substitution. Here is an example of stalks of small
levels: $\varepsilon$ (the empty context) for $n=0$; $(x_0 : *, x_1 : *)$ for
$n=1$; $(x_0 : *, x_1 : *, x_2 : x_0\,=_\mathsf{h}\,x_1, x_3 :
x_0\,=_\mathsf{h}\,x_1)$ for $n=2$, etc. 
 \[
 \begin{array}{c@{\hspace{1.5cm}} c@{\hspace{1.5cm}} c@{\hspace{1.5cm}} c@{\hspace{1.5cm}} c@{\hspace{1.5cm}}}
 &&&&6\quad 7\\
 &&&4\quad 5&4 \quad 5\\
 &&2\quad 3&2\quad 3&2\quad 3\\
 &0\quad 1&0\quad 1&0\quad 1&0\quad 1\\
 \\
 n = 0 & n = 1 & n = 2 & n = 3 & n = 4 
 \end{array}
 \]

This is the $\Delta = \varepsilon$ case of a more general construction
where in we \emph{suspend} an arbitrary context $\Delta$ by adding $2n$
variables to the beginning of it, and weakening the rest of the
variables appropriately so that type $*$ becomes $x_{2n-2} =_\mathsf{h}
x_{2n-1}$. A crucial property of suspension is that it preserves
contractibility. 


\subsubsection{Suspension}
\label{sec:susp}

\emph{Suspension} is defined by iteration level-$A$-times the following
operation of one-level suspension. \AgdaFunction{ΣC} takes a
context and gives a context with two new variables of type $*$ added
at the beginning, and with all remaining types in the context suspended
by one level. 

\begin{code}\>\<%
\\
\>\AgdaFunction{ΣC} \AgdaSymbol{:} \AgdaDatatype{Con} \AgdaSymbol{→} \AgdaDatatype{Con}\<%
\\
\>\AgdaFunction{ΣT} \AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Ty} \AgdaBound{Γ} \AgdaSymbol{→} \AgdaDatatype{Ty} \AgdaSymbol{(}\AgdaFunction{ΣC} \AgdaBound{Γ}\AgdaSymbol{)}\<%
\\
%
\\
\>\AgdaFunction{ΣC} \AgdaInductiveConstructor{ε} \<[12]%
\>[12]\AgdaSymbol{=} \AgdaInductiveConstructor{ε} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{*} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{*}\<%
\\
\>\AgdaFunction{ΣC} \AgdaSymbol{(}\AgdaBound{Γ} \AgdaInductiveConstructor{,} \AgdaBound{A}\AgdaSymbol{)} \<[12]%
\>[12]\AgdaSymbol{=} \AgdaFunction{ΣC} \AgdaBound{Γ} \AgdaInductiveConstructor{,} \AgdaFunction{ΣT} \AgdaBound{A}\<%
\\
\>\<\end{code}
\noindent The rest of the definitions is straightforward by structural
recursion. In particular we suspend variables, terms and context morphisms:

\begin{code}\>\<%
\\
\>\AgdaFunction{Σv} \<[5]%
\>[5]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Var} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Var} \AgdaSymbol{(}\AgdaFunction{ΣT} \AgdaBound{A}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{Σtm} \<[5]%
\>[5]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaBound{A} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaSymbol{(}\AgdaFunction{ΣT} \AgdaBound{A}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{Σs} \<[5]%
\>[5]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ} \AgdaSymbol{→} \AgdaFunction{ΣC} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaFunction{ΣC} \AgdaBound{Δ}\<%
\\
\>\<\end{code}
\noindent The following lemma establishes preservation of contractibility by
one-step suspension:

\begin{code}\>\<%
\\
\>\AgdaFunction{ΣC-Contr} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaBound{Δ} \AgdaSymbol{→} \AgdaDatatype{isContr} \AgdaBound{Δ} \AgdaSymbol{→} \AgdaDatatype{isContr} \AgdaSymbol{(}\AgdaFunction{ΣC} \AgdaBound{Δ}\AgdaSymbol{)}\<%
\\
\>\<\end{code}
\noindent It is also essential that suspension respects weakening and substitution:

\begin{code}\>\<%
\\
\>\AgdaFunction{ΣT[+T]} \<[9]%
\>[9]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaBound{B} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \<[28]%
\>[28]\<%
\\
\>[8]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{→} \AgdaFunction{ΣT} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{+T} \AgdaBound{B}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaFunction{ΣT} \AgdaBound{A} \AgdaFunction{+T} \AgdaFunction{ΣT} \AgdaBound{B}\<%
\\
%
\\
\>\AgdaFunction{Σtm[+tm]} \AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{A}\AgdaSymbol{\}(}\AgdaBound{a} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaBound{A}\AgdaSymbol{)(}\AgdaBound{B} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \<[38]%
\>[38]\<%
\\
\>[8]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{→} \AgdaFunction{Σtm} \AgdaSymbol{(}\AgdaBound{a} \AgdaFunction{+tm} \AgdaBound{B}\AgdaSymbol{)} \AgdaDatatype{≅} \AgdaFunction{Σtm} \AgdaBound{a} \AgdaFunction{+tm} \AgdaFunction{ΣT} \AgdaBound{B}\<%
\\
%
\\
\>\AgdaFunction{ΣT[Σs]T} \<[9]%
\>[9]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Δ}\AgdaSymbol{)(}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{)} \<[39]%
\>[39]\<%
\\
\>[8]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{→} \AgdaSymbol{(}\AgdaFunction{ΣT} \AgdaBound{A}\AgdaSymbol{)} \AgdaFunction{[} \AgdaFunction{Σs} \AgdaBound{δ} \AgdaFunction{]T} \AgdaDatatype{≡} \AgdaFunction{ΣT} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]T}\AgdaSymbol{)}\<%
\\
\>\<\end{code}
General suspension to the level of a type $A$ is defined by iteration of
one-level suspension. For symmetry and ease of reading the following
suspension functions take as a parameter a type $A$ in $\Gamma$, while they
depend only on its level. 

\begin{code}\>\<%
\\
\>\AgdaFunction{ΣC-it} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Con} \AgdaSymbol{→} \AgdaDatatype{Con}\<%
\\
%
\\
\>\AgdaFunction{ΣT-it} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Ty} \AgdaBound{Δ} \AgdaSymbol{→} \AgdaDatatype{Ty} \AgdaSymbol{(}\AgdaFunction{ΣC-it} \AgdaBound{A} \AgdaBound{Δ}\AgdaSymbol{)}\<%
\\
%
\\
\>\AgdaFunction{Σtm-it} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)\{}\AgdaBound{B} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Δ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaBound{B} \<[44]%
\>[44]\<%
\\
\>[0]\AgdaIndent{8}{}\<[8]%
\>[8]\AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaSymbol{(}\AgdaFunction{ΣT-it} \AgdaBound{A} \AgdaBound{B}\AgdaSymbol{)}\<%
\\
\>\<\end{code}
\noindent Finally, it is clear that iterated suspension preserves contractibility. 

\begin{code}\>\<%
\\
\>\AgdaFunction{ΣC-it-Contr} \<[13]%
\>[13]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaBound{Δ}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{isContr} \AgdaBound{Δ} \<[45]%
\>[45]\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{→} \AgdaDatatype{isContr} \AgdaSymbol{(}\AgdaFunction{ΣC-it} \AgdaBound{A} \AgdaBound{Δ}\AgdaSymbol{)}\<%
\\
\>\<\end{code}
By suspending the minimal contractible context,
*, we obtain a so-called \emph{span}. They are stalks with a top variable added. For example $(x_0: *)$ (the one-variable
context) for $n=0$; $(x_0 : *, x_1 : *, x_2 : x_0\,=_\mathsf{h}\,x_1)$ for
$n=1$; $(x_0 : *, x_1 : *, x_2 : x_0\,=_\mathsf{h}\,x_1, x_3 :
x_0\,=_{\mathsf{h}}\,x_1, x_4 : x_2\,=_\mathsf{h}\,x_3)$ for $n=2$, etc. 
Spans play
an important role later in the definition of composition. 
 Following is a picture of the first few spans for increasing levels $n$ of \AgdaBound{A}.
 \[
 \begin{array}{c@{\hspace{1.5cm}} c@{\hspace{1.5cm}} c@{\hspace{1.5cm}} c@{\hspace{1.5cm}} c@{\hspace{1.5cm}}}
 &&&&8\\
 &&&6&6\quad 7\\
 &&4&4\quad 5&4 \quad 5\\
 &2&2\quad 3&2\quad 3&2\quad 3\\
 0&0\quad 1&0\quad 1&0\quad 1&0\quad 1\\
 \\
 n = 0&n=1&n=2&n=3&n=4
 \end{array}
 \]

\subsubsection{Replacement}
\label{sec:replacement}

After we have suspended a context by inserting an appropriate number of
variables, we may proceed to a substitution which, so to speak, fills the stalk for
$A$ with $A$. The context morphism representing this substitution is
called $\AgdaFunction{filter}$. In the final step we combine it with
$\Gamma$, the context of $A$.  The new context contains two parts, the
first is the same as $\Gamma$, and the second is the suspended $\Delta$
substituted by $\AgdaFunction{filter}$. However, we also have to drop
the stalk of $A$ because it already exists in $\Gamma$.

This operation is called \emph{replacement} because we can interpret it as replacing $*$ in $\Delta$ by
$A$.

As always, we define replacement for contexts, types and terms simultaneously:

\begin{code}\>\<%
\\
\>\AgdaFunction{rpl-C} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Con} \AgdaSymbol{→} \AgdaDatatype{Con}\<%
\\
\>\AgdaFunction{rpl-T} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Ty} \AgdaBound{Δ} \AgdaSymbol{→} \AgdaDatatype{Ty} \AgdaSymbol{(}\AgdaFunction{rpl-C} \AgdaBound{A} \AgdaBound{Δ}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{rpl-tm} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)\{}\AgdaBound{B} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Δ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaBound{B} \<[44]%
\>[44]\<%
\\
\>[0]\AgdaIndent{8}{}\<[8]%
\>[8]\AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaSymbol{(}\AgdaFunction{rpl-T} \AgdaBound{A} \AgdaBound{B}\AgdaSymbol{)}\<%
\\
\>\<\end{code}
Replacement for contexts, $\AgdaFunction{rpl-C}$, defines for a type $A$ in $\Gamma$ and another context $\Delta$ 
a context which begins as $\Gamma$ and follows by each type of $\Delta$ with $*$ replaced with (pasted onto)  $A$. 

\begin{code}\>\<%
\\
\>\AgdaFunction{rpl-C} \AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSymbol{\}} \AgdaBound{A} \AgdaInductiveConstructor{ε} \<[17]%
\>[17]\AgdaSymbol{=} \AgdaBound{Γ}\<%
\\
\>\AgdaFunction{rpl-C} \AgdaBound{A} \AgdaSymbol{(}\AgdaBound{Δ} \AgdaInductiveConstructor{,} \AgdaBound{B}\AgdaSymbol{)} \<[17]%
\>[17]\AgdaSymbol{=} \AgdaFunction{rpl-C} \AgdaBound{A} \AgdaBound{Δ} \AgdaInductiveConstructor{,} \AgdaFunction{rpl-T} \AgdaBound{A} \AgdaBound{B}\<%
\\
\>\<\end{code}
\noindent To this end we must define the substitution $\AgdaFunction{filter}$ which
pulls back each type from suspended $\Delta$ to the new context. 

\begin{code}\>\<%
\\
\>\AgdaFunction{filter} \<[8]%
\>[8]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}(}\AgdaBound{Δ} \AgdaSymbol{:} \AgdaDatatype{Con}\AgdaSymbol{)(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \<[34]%
\>[34]\<%
\\
\>[0]\AgdaIndent{8}{}\<[8]%
\>[8]\AgdaSymbol{→} \AgdaFunction{rpl-C} \AgdaBound{A} \AgdaBound{Δ} \AgdaDatatype{⇒} \AgdaFunction{ΣC-it} \AgdaBound{A} \AgdaBound{Δ}\<%
\\
%
\\
\>\AgdaFunction{rpl-T} \AgdaBound{A} \AgdaBound{B} \AgdaSymbol{=} \AgdaFunction{ΣT-it} \AgdaBound{A} \AgdaBound{B} \AgdaFunction{[} \AgdaFunction{filter} \AgdaSymbol{\_} \AgdaBound{A} \AgdaFunction{]T}\<%
\\
\>\<\end{code}


\subsection{First-level Groupoid Structure}
We can proceed to the definition of the groupoid structure of the syntax. We start with the base case: 1-cells. Replacement defined above allows us to lift this structure to an arbitrary level $n$ (we leave most of the routine details out). This shows that the syntax is a 1-groupoid on each level. In the next section we show how also the higher-groupoid structure can be defined. 

We start by an essential lemma which formalises the discussion at the
beginning of this section: to construct a term in a type $A$ in an
arbitrary context, we first restrict attention to a suitable
contractible context $\Delta$ and use lifting and substitution -- replacement -- to pull
 the term built by $\AgdaInductiveConstructor{coh}$ in $\Delta$
back. This relies on the fact that a lifted contractible context is
also contractible, and therefore any type lifted from a contractible
context is also inhabited.

\begin{code}\>\<%
\\
\>\AgdaFunction{Coh-rpl} \<[9]%
\>[9]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)(}\AgdaBound{B} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Δ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{isContr} \AgdaBound{Δ}\<%
\\
\>[0]\AgdaIndent{9}{}\<[9]%
\>[9]\AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaSymbol{(}\AgdaFunction{rpl-T} \AgdaBound{A} \AgdaBound{B}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{Coh-rpl} \AgdaSymbol{\{\_\}} \AgdaSymbol{\{}\AgdaBound{Δ}\AgdaSymbol{\}} \AgdaBound{A} \AgdaSymbol{\_} \AgdaBound{isC} \AgdaSymbol{=} \AgdaInductiveConstructor{coh} \AgdaSymbol{(}\AgdaFunction{ΣC-it-ε-Contr} \AgdaBound{A} \AgdaBound{isC}\AgdaSymbol{)} \AgdaSymbol{\_} \AgdaSymbol{\_}\<%
\\
\>\<\end{code}
Next we define the reflexivity, symmetry and transitivity terms of any type. Let us start from some base cases. Each of the base cases is derivable in a different contractible context with \AgdaFunction{Coh-Contr} which gives you a coherence constant for any type in any contractible context.

\noindent \textbf{Reflexivity} (identity) It only requires a one-object context.

\begin{code}\>\<%
\\
\>\AgdaFunction{refl*-Tm} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaSymbol{\{}\AgdaFunction{x:*}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaInductiveConstructor{var} \AgdaInductiveConstructor{v0} \AgdaInductiveConstructor{=h} \AgdaInductiveConstructor{var} \AgdaInductiveConstructor{v0}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{refl*-Tm} \AgdaSymbol{=} \AgdaFunction{Coh-Contr} \AgdaInductiveConstructor{c*}\<%
\\
\>\<\end{code}
\noindent  \textbf{Symmetry} (inverse) It is defined similarly. Note that the intricate names of contexts, as in \AgdaDatatype{Ty} \AgdaFunction{x:*,y:*,α:x=y} indicate their definitions which have been hidden. Agda treats all sequences of characters uninterrupted by whitespace as identifiers. For instance \AgdaFunction{x:*,y:*,α:x=y} is a name of a context for which we are assuming the definition:
\AgdaFunction{x:*,y:*,α:x=y} \AgdaSymbol{=} \AgdaInductiveConstructor{ε} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{*} \AgdaInductiveConstructor{,} \AgdaInductiveConstructor{*} \AgdaInductiveConstructor{,} \AgdaSymbol{(}\AgdaInductiveConstructor{var} \AgdaSymbol{(}\AgdaInductiveConstructor{vS} \AgdaInductiveConstructor{v0}\AgdaSymbol{)} \AgdaInductiveConstructor{=h} \AgdaInductiveConstructor{var} \AgdaInductiveConstructor{v0}\AgdaSymbol{)}.


\begin{code}\>\<%
\\
\>\AgdaFunction{sym*-Ty} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaFunction{x:*,y:*,α:x=y}\<%
\\
\>\AgdaFunction{sym*-Ty} \AgdaSymbol{=} \AgdaFunction{vY} \AgdaInductiveConstructor{=h} \AgdaFunction{vX}\<%
\\
%
\\
\>\AgdaFunction{sym*-Tm} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaSymbol{\{}\AgdaFunction{x:*,y:*,α:x=y}\AgdaSymbol{\}} \AgdaFunction{sym*-Ty}\<%
\\
\>\AgdaFunction{sym*-Tm} \AgdaSymbol{=} \AgdaFunction{Coh-Contr} \AgdaSymbol{(}\AgdaInductiveConstructor{ext} \AgdaInductiveConstructor{c*} \AgdaInductiveConstructor{v0}\AgdaSymbol{)}\<%
\\
\>\<\end{code}
\textbf{Transitivity} (composition)

\begin{code}\>\<%
\\
\>\AgdaFunction{trans*-Ty} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaFunction{x:*,y:*,α:x=y,z:*,β:y=z}\<%
\\
\>\AgdaFunction{trans*-Ty} \AgdaSymbol{=} \AgdaSymbol{(}\AgdaFunction{vX} \AgdaFunction{+tm} \AgdaSymbol{\_} \AgdaFunction{+tm} \AgdaSymbol{\_)} \AgdaInductiveConstructor{=h} \AgdaFunction{vZ}\<%
\\
%
\\
\>\AgdaFunction{trans*-Tm} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaFunction{trans*-Ty}\<%
\\
\>\AgdaFunction{trans*-Tm} \AgdaSymbol{=} \AgdaFunction{Coh-Contr} \AgdaSymbol{(}\AgdaInductiveConstructor{ext} \AgdaSymbol{(}\AgdaInductiveConstructor{ext} \AgdaInductiveConstructor{c*} \AgdaInductiveConstructor{v0}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{vS} \AgdaInductiveConstructor{v0}\AgdaSymbol{))}\<%
\\
\>\<\end{code}
\noindent To obtain these terms for any given type in any give context, we use replacement.

\begin{code}\>\<%
\\
\>\AgdaFunction{refl-Tm} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaSymbol{:} \AgdaDatatype{Con}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \<[33]%
\>[33]\<%
\\
\>[9]\AgdaIndent{11}{}\<[11]%
\>[11]\AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaSymbol{(}\AgdaFunction{rpl-T} \AgdaSymbol{\{}Δ \AgdaSymbol{=} \AgdaFunction{x:*}\AgdaSymbol{\}} \AgdaBound{A} \AgdaSymbol{(}\AgdaInductiveConstructor{var} \AgdaInductiveConstructor{v0} \AgdaInductiveConstructor{=h} \AgdaInductiveConstructor{var} \AgdaInductiveConstructor{v0}\AgdaSymbol{))}\<%
\\
\>\AgdaFunction{refl-Tm} \AgdaBound{A} \<[11]%
\>[11]\AgdaSymbol{=} \AgdaFunction{rpl-tm} \AgdaBound{A} \AgdaFunction{refl*-Tm}\<%
\\
%
\\
\>\AgdaFunction{sym-Tm} \<[10]%
\>[10]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaSymbol{(}\AgdaFunction{rpl-T} \AgdaBound{A} \AgdaFunction{sym*-Ty}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{sym-Tm} \AgdaBound{A} \<[10]%
\>[10]\AgdaSymbol{=} \AgdaFunction{rpl-tm} \AgdaBound{A} \AgdaFunction{sym*-Tm}\<%
\\
%
\\
\>\AgdaFunction{trans-Tm} \<[12]%
\>[12]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaSymbol{(}\AgdaFunction{rpl-T} \AgdaBound{A} \AgdaFunction{trans*-Ty}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{trans-Tm} \AgdaBound{A} \<[12]%
\>[12]\AgdaSymbol{=} \AgdaFunction{rpl-tm} \AgdaBound{A} \AgdaFunction{trans*-Tm}\<%
\\
\>\<\end{code}
For each of reflexivity, symmetry and transitivity we can construct appropriate coherence $2$-cells witnessing the groupoid laws. The base case for variable contexts is proved simply using contractibility as well. However the types of these laws are not as trivial as the proving parts. We use substitution to define the application of the three basic terms we have defined above.

\begin{code}\>\<%
\\
\>\AgdaFunction{Tm-right-identity*} \AgdaSymbol{:} \<[21]%
\>[21]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaDatatype{Tm} \AgdaSymbol{\{}\AgdaFunction{x:*,y:*,α:x=y}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaFunction{trans*-Tm} \AgdaFunction{[} \AgdaFunction{IdS} \AgdaInductiveConstructor{,} \AgdaFunction{vY} \AgdaInductiveConstructor{,} \AgdaFunction{reflY} \AgdaFunction{]tm} \<[55]%
\>[55]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{=h} \AgdaFunction{vα}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{Tm-right-identity*} \AgdaSymbol{=} \AgdaFunction{Coh-Contr} \AgdaSymbol{(}\AgdaInductiveConstructor{ext} \AgdaInductiveConstructor{c*} \AgdaInductiveConstructor{v0}\AgdaSymbol{)}\<%
\\
%
\\
\>\AgdaFunction{Tm-left-identity*} \AgdaSymbol{:} \<[20]%
\>[20]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaDatatype{Tm} \AgdaSymbol{\{}\AgdaFunction{x:*,y:*,α:x=y}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaFunction{trans*-Tm} \AgdaFunction{[} \AgdaSymbol{((}\AgdaFunction{IdS} \AgdaFunction{⊚} \AgdaFunction{pr1} \AgdaFunction{⊚} \AgdaFunction{pr1}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaFunction{vX}\AgdaSymbol{)} \AgdaInductiveConstructor{,}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{reflX} \AgdaInductiveConstructor{,} \AgdaFunction{vY} \AgdaInductiveConstructor{,} \AgdaFunction{vα} \AgdaFunction{]tm} \AgdaInductiveConstructor{=h} \AgdaFunction{vα}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{Tm-left-identity*} \AgdaSymbol{=} \AgdaFunction{Coh-Contr} \AgdaSymbol{(}\AgdaInductiveConstructor{ext} \AgdaInductiveConstructor{c*} \AgdaInductiveConstructor{v0}\AgdaSymbol{)}\<%
\\
%
\\
\>\AgdaFunction{Tm-right-inverse*} \AgdaSymbol{:} \<[20]%
\>[20]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaDatatype{Tm} \AgdaSymbol{\{}\AgdaFunction{x:*,y:*,α:x=y}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaFunction{trans*-Tm} \AgdaFunction{[} \AgdaSymbol{(}\AgdaFunction{IdS} \AgdaInductiveConstructor{,} \AgdaFunction{vX}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaFunction{sym*-Tm} \AgdaFunction{]tm} \<[59]%
\>[59]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaInductiveConstructor{=h} \AgdaFunction{reflX}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{Tm-right-inverse*} \AgdaSymbol{=} \AgdaFunction{Coh-Contr} \AgdaSymbol{(}\AgdaInductiveConstructor{ext} \AgdaInductiveConstructor{c*} \AgdaInductiveConstructor{v0}\AgdaSymbol{)}\<%
\\
%
\\
\>\AgdaFunction{Tm-left-inverse*} \AgdaSymbol{:} \<[19]%
\>[19]\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaDatatype{Tm} \AgdaSymbol{\{}\AgdaFunction{x:*,y:*,α:x=y}\AgdaSymbol{\}} \AgdaSymbol{(}\AgdaFunction{trans*-Tm} \AgdaFunction{[} \AgdaSymbol{((}\AgdaInductiveConstructor{•} \AgdaInductiveConstructor{,} \AgdaFunction{vY}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaFunction{vX} \AgdaInductiveConstructor{,} \AgdaFunction{sym*-Tm} \AgdaInductiveConstructor{,}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaFunction{vY}\AgdaSymbol{)} \AgdaInductiveConstructor{,} \AgdaFunction{vα} \AgdaFunction{]tm} \AgdaInductiveConstructor{=h} \AgdaFunction{reflY}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{Tm-left-inverse*} \AgdaSymbol{=} \AgdaFunction{Coh-Contr} \AgdaSymbol{(}\AgdaInductiveConstructor{ext} \AgdaInductiveConstructor{c*} \AgdaInductiveConstructor{v0}\AgdaSymbol{)}\<%
\\
%
\\
\>\AgdaFunction{Tm-G-assoc*} \<[13]%
\>[13]\AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaFunction{Ty-G-assoc*}\<%
\\
\>\AgdaFunction{Tm-G-assoc*} \<[13]%
\>[13]\AgdaSymbol{=} \AgdaFunction{Coh-Contr} \AgdaSymbol{(}\AgdaInductiveConstructor{ext} \AgdaSymbol{(}\AgdaInductiveConstructor{ext} \AgdaSymbol{(}\AgdaInductiveConstructor{ext} \AgdaInductiveConstructor{c*} \AgdaInductiveConstructor{v0}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaInductiveConstructor{vS} \AgdaInductiveConstructor{v0}\AgdaSymbol{))} \<[56]%
\>[56]\<%
\\
\>[2]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{(}\AgdaInductiveConstructor{vS} \AgdaInductiveConstructor{v0}\AgdaSymbol{))}\<%
\\
\>\<\end{code}
\noindent Their general versions are defined using replacement. For instance, for associativity, we define:

\begin{code}\>\<%
\\
\>\AgdaFunction{Tm-G-assoc} \<[14]%
\>[14]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Γ}\AgdaSymbol{)} \<[31]%
\>[31]\<%
\\
\>[13]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaSymbol{(}\AgdaFunction{rpl-T} \AgdaBound{A} \AgdaFunction{Ty-G-assoc*}\AgdaSymbol{)}\<%
\\
\>\AgdaFunction{Tm-G-assoc} \AgdaBound{A} \<[14]%
\>[14]\AgdaSymbol{=} \AgdaFunction{rpl-tm} \AgdaBound{A} \AgdaFunction{Tm-G-assoc*} \<[37]%
\>[37]\<%
\\
\>\<\end{code}
Following the same pattern, the $n$-level groupoid laws can be
obtained as the coherence constants as well.

\subsection{Higher Structure} In the previous text we have shown how
to define 1-groupoid structure on an arbitrary level. Here we indicate
how all levels also bear the structure of $n$-groupoid for arbitrary
$n$. The rough idea amounts to redefining telescopes of \cite{txa:csl}
in terms of appropriate contexts, which are contractible, and the different
constructors for terms used in \cite{txa:csl} in terms of
$\mathsf{coh}$.

To illustrate this we consider the simpler example of higher
identities. Note that the domain and codomain of $n\text{+}1$-iterated
identity are $n$-iterated identities. Hence we proceed by induction on
$n$. Denote a span of depth $n$ $S_n$. Then there is a chain of
context morphisms $S_0 \Rightarrow S_1 \Rightarrow \cdots \Rightarrow
S_n$. Each $S_{n+1}$ has one additional variable standing for the
identity iterated $n\text{+}1$-times. Because $S_{n+1}$ is contractible, one
can define a morphism $S_n \Rightarrow S_{n+1}$ using $\AgdaInductiveConstructor{coh}$
to fill the last variable and variable terms on the first $n$
levels. By composition of the context morphisms one defines $n$ new
terms in the basic one variable context $*$ -- the iterated
identities. Finally, using suspension one can lift the identities to an
arbitrary level.

Each $n$-cell has $n$-compositions. In the case of
2-categories, 1-cells have one composition, 2-cells have vertical and
horizontal composition. Two 2-cells are horizontally composable only
if their 1-cell top and bottom boundaries are composable. The boundary
of the composition is the composition of the boundaries.  Thus for
arbitrary $n$ we proceed using a chain of $V$-shaped contractible
contexts. That is contexts that are two spans conjoined at the base
level at a common middle variable. Each successive composition is
defined using contractibility and \AgdaInductiveConstructor{coh}.

To fully imitate the development in \cite{txa:csl}, one would
also have to define all higher coherence laws. But the sole purpose
of giving an alternative type theory in this chapter is to avoid that. 

\section{Semantics}

\subsection{Globular Types}

To interpret the syntax, we need globular types
\footnote{The Agda \AgdaPrimitiveType{Set} stands for an arbitrary type, not a set in the sense of Homotopy Type Theory.}
. Globular types are defined coinductively as follows:

\begin{code}\>\<%
\\
\>\AgdaKeyword{record} \AgdaRecord{Glob} \AgdaSymbol{:} \AgdaPrimitiveType{Set₁} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{constructor} \AgdaInductiveConstructor{\_∣∣\_}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{∣\_∣} \<[10]%
\>[10]\AgdaSymbol{:} \AgdaPrimitiveType{Set}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{hom} \<[9]%
\>[9]\AgdaSymbol{:} \AgdaBound{∣\_∣} \AgdaSymbol{→} \AgdaBound{∣\_∣} \AgdaSymbol{→} \AgdaDatatype{∞} \AgdaRecord{Glob}\<%
\\
\>\<\end{code}
\AgdaHide{
\begin{code}\>\<%
\\
\>\AgdaKeyword{open} \AgdaModule{Glob} \AgdaKeyword{public}\<%
\\
\>\<\end{code}
}
If all the object types ($\AgdaField{∣\_∣}$) are indeed sets, i.e.\
UIP holds for them, we call this a globular set.

%Indeed, we should assume the 0-level object to be an h-set, namely the equality of any two terms of it should be unique. 

As an example, we could construct the identity globular type called $\AgdaFunction{Idω}$.

\begin{code}\>\<%
\\
\>\AgdaFunction{Idω} \<[7]%
\>[7]\AgdaSymbol{:} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{:} \AgdaPrimitiveType{Set}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaRecord{Glob}\<%
\\
\>\AgdaFunction{Idω} \AgdaBound{A} \<[7]%
\>[7]\AgdaSymbol{=} \AgdaBound{A} \AgdaInductiveConstructor{∣∣} \AgdaSymbol{(λ} \AgdaBound{a} \AgdaBound{b} \AgdaSymbol{→} \AgdaCoinductiveConstructor{♯} \AgdaFunction{Idω} \AgdaSymbol{(}\AgdaBound{a} \AgdaDatatype{≡} \AgdaBound{b}\AgdaSymbol{))}\<%
\\
\>\<\end{code}
% Note that this is usually not a globular set, because UIP does not necessary for object types on each level, i.e.\ $\AgdaBound{A}$, $\AgdaBound{a}\AgdaDatatype{≡}\AgdaBound{b}$ and so on.

Given a globular type $G$, we can interpret the syntactic objects.

\begin{code}\>\<%
\\
\>\AgdaKeyword{record} \AgdaRecord{Semantic} \AgdaSymbol{(}\AgdaBound{G} \AgdaSymbol{:} \AgdaRecord{Glob}\AgdaSymbol{)} \AgdaSymbol{:} \AgdaPrimitiveType{Set₁} \AgdaKeyword{where}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{⟦\_⟧C} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaDatatype{Con} \AgdaSymbol{→} \AgdaPrimitiveType{Set}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{⟦\_⟧T} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Ty} \AgdaBound{Γ} \AgdaSymbol{→} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C} \AgdaSymbol{→} \AgdaRecord{Glob}\<%
\\
\>[2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{⟦\_⟧tm} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{A}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Tm} \AgdaBound{A} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C}\AgdaSymbol{)} \<[42]%
\>[42]\<%
\\
\>[4]\AgdaIndent{11}{}\<[11]%
\>[11]\AgdaSymbol{→} \AgdaFunction{∣} \AgdaBound{⟦} \AgdaBound{A} \AgdaBound{⟧T} \AgdaBound{γ} \AgdaFunction{∣}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{⟦\_⟧S} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ} \AgdaSymbol{→} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C} \AgdaSymbol{→} \AgdaBound{⟦} \AgdaBound{Δ} \AgdaBound{⟧C}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{π} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{A}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{Var} \AgdaBound{A} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C}\AgdaSymbol{)} \<[43]%
\>[43]\<%
\\
\>[4]\AgdaIndent{11}{}\<[11]%
\>[11]\AgdaSymbol{→} \AgdaFunction{∣} \AgdaBound{⟦} \AgdaBound{A} \AgdaBound{⟧T} \AgdaBound{γ} \AgdaFunction{∣}\<%
\\
\>\<\end{code}
$\AgdaField{π}$ provides the projection of the semantic variable out of a semantic context.

Following are the computation laws for the interpretations of contexts and types.

\begin{code}\>\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{⟦\_⟧C-β1} \<[13]%
\>[13]\AgdaSymbol{:} \AgdaBound{⟦} \AgdaInductiveConstructor{ε} \AgdaBound{⟧C} \AgdaDatatype{≡} \AgdaRecord{⊤}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{⟦\_⟧C-β2} \<[13]%
\>[13]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaBound{A}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaInductiveConstructor{,} \AgdaBound{A} \AgdaBound{⟧C} \AgdaDatatype{≡} \<[38]%
\>[38]\<%
\\
\>[4]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaRecord{Σ} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C} \AgdaSymbol{(λ} \AgdaBound{γ} \<[28]%
\>[28]\AgdaSymbol{→} \AgdaFunction{∣} \AgdaBound{⟦} \AgdaBound{A} \AgdaBound{⟧T} \AgdaBound{γ} \AgdaFunction{∣}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{⟦\_⟧T-β1} \<[13]%
\>[13]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}\{}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaBound{⟦} \AgdaInductiveConstructor{*} \AgdaBound{⟧T} \AgdaBound{γ} \AgdaDatatype{≡} \AgdaBound{G}\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{⟦\_⟧T-β2} \<[13]%
\>[13]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{A} \AgdaBound{u} \AgdaBound{v}\AgdaSymbol{\}\{}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C}\AgdaSymbol{\}}\<%
\\
\>[4]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{→} \AgdaBound{⟦} \AgdaBound{u} \AgdaInductiveConstructor{=h} \AgdaBound{v} \AgdaBound{⟧T} \AgdaBound{γ} \AgdaDatatype{≡}\<%
\\
\>[4]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaFunction{♭} \AgdaSymbol{(}\AgdaFunction{hom} \AgdaSymbol{(}\AgdaBound{⟦} \AgdaBound{A} \AgdaBound{⟧T} \AgdaBound{γ}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{⟦} \AgdaBound{u} \AgdaBound{⟧tm} \AgdaBound{γ}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{⟦} \AgdaBound{v} \AgdaBound{⟧tm} \AgdaBound{γ}\AgdaSymbol{))}\<%
\\
\>\<\end{code}
Semantic substitution and semantic weakening laws are also required.
The semantic substitution properties are essential for dealing with substitutions inside interpretation,

\begin{code}\>\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{semSb-T} \<[14]%
\>[14]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaBound{Δ}\AgdaSymbol{\}(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Δ}\AgdaSymbol{)(}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{)(}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaSymbol{→} \AgdaBound{⟦} \AgdaBound{A} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]T} \AgdaBound{⟧T} \AgdaBound{γ} \AgdaDatatype{≡} \AgdaBound{⟦} \AgdaBound{A} \AgdaBound{⟧T} \AgdaSymbol{(}\AgdaBound{⟦} \AgdaBound{δ} \AgdaBound{⟧S} \AgdaBound{γ}\AgdaSymbol{)}\<%
\\
%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{semSb-tm} \<[14]%
\>[14]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ}\AgdaSymbol{\}\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Δ}\AgdaSymbol{\}(}\AgdaBound{a} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaBound{A}\AgdaSymbol{)(}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaSymbol{(}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaFunction{subst} \AgdaFunction{∣\_∣} \AgdaSymbol{(}\AgdaBound{semSb-T} \AgdaBound{A} \AgdaBound{δ} \AgdaBound{γ}\AgdaSymbol{)} \<[55]%
\>[55]\<%
\\
\>[0]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaSymbol{(}\AgdaBound{⟦} \AgdaBound{a} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]tm} \AgdaBound{⟧tm} \AgdaBound{γ}\AgdaSymbol{)} \AgdaDatatype{≡} \AgdaBound{⟦} \AgdaBound{a} \AgdaBound{⟧tm} \AgdaSymbol{(}\AgdaBound{⟦} \AgdaBound{δ} \AgdaBound{⟧S} \AgdaBound{γ}\AgdaSymbol{)}\<%
\\
%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{semSb-S} \<[14]%
\>[14]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaBound{Δ} \AgdaBound{Θ}\AgdaSymbol{\}(}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C}\AgdaSymbol{)(}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaSymbol{(}\AgdaBound{θ} \AgdaSymbol{:} \AgdaBound{Δ} \AgdaDatatype{⇒} \AgdaBound{Θ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{⟦} \AgdaBound{θ} \AgdaFunction{⊚} \AgdaBound{δ} \AgdaBound{⟧S} \AgdaBound{γ} \AgdaDatatype{≡} \<[43]%
\>[43]\<%
\\
\>[0]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaBound{⟦} \AgdaBound{θ} \AgdaBound{⟧S} \AgdaSymbol{(}\AgdaBound{⟦} \AgdaBound{δ} \AgdaBound{⟧S} \AgdaBound{γ}\AgdaSymbol{)}\<%
\\
\>\<\end{code}
Since the computation laws for the interpretations of terms and context morphisms are well typed up to these properties.

\begin{code}\>\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{⟦\_⟧tm-β1} \<[14]%
\>[14]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{A}\AgdaSymbol{\}\{}\AgdaBound{x} \AgdaSymbol{:} \AgdaDatatype{Var} \AgdaBound{A}\AgdaSymbol{\}\{}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C}\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{14}{}\<[14]%
\>[14]\AgdaSymbol{→} \AgdaBound{⟦} \AgdaInductiveConstructor{var} \AgdaBound{x} \AgdaBound{⟧tm} \AgdaBound{γ} \AgdaDatatype{≡} \AgdaBound{π} \AgdaBound{x} \AgdaBound{γ}\<%
\\
%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{⟦\_⟧S-β1} \<[13]%
\>[13]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ}\AgdaSymbol{\}\{}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C}\AgdaSymbol{\}} \<[32]%
\>[32]\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{→} \AgdaBound{⟦} \AgdaInductiveConstructor{•} \AgdaBound{⟧S} \AgdaBound{γ} \AgdaDatatype{≡} \AgdaFunction{coerce} \AgdaBound{⟦\_⟧C-β1} \AgdaInductiveConstructor{tt}\<%
\\
%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{⟦\_⟧S-β2} \<[13]%
\>[13]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{Δ}\AgdaSymbol{\}\{}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Δ}\AgdaSymbol{\}\{}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{\}\{}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C}\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{\{}\AgdaBound{a} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaSymbol{(}\AgdaBound{A} \AgdaFunction{[} \AgdaBound{δ} \AgdaFunction{]T}\AgdaSymbol{)\}} \AgdaSymbol{→} \AgdaBound{⟦} \AgdaBound{δ} \AgdaInductiveConstructor{,} \AgdaBound{a} \AgdaBound{⟧S} \AgdaBound{γ} \<[48]%
\>[48]\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaDatatype{≡} \AgdaFunction{coerce} \AgdaBound{⟦\_⟧C-β2} \AgdaSymbol{((}\AgdaBound{⟦} \AgdaBound{δ} \AgdaBound{⟧S} \AgdaBound{γ}\AgdaSymbol{)} \AgdaInductiveConstructor{,}\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaFunction{subst} \AgdaFunction{∣\_∣} \AgdaSymbol{(}\AgdaBound{semSb-T} \AgdaBound{A} \AgdaBound{δ} \AgdaBound{γ}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{⟦} \AgdaBound{a} \AgdaBound{⟧tm} \AgdaBound{γ}\AgdaSymbol{))}\<%
\\
\>\<\end{code}
The semantic weakening properties should actually be derivable since weakening is equivalent to projection substitution.

\begin{code}\>\<%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{semWk-T} \<[13]%
\>[13]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaBound{A} \AgdaBound{B}\AgdaSymbol{\}(}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C}\AgdaSymbol{)(}\AgdaBound{v} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{⟦} \AgdaBound{B} \AgdaBound{⟧T} \AgdaBound{γ} \AgdaFunction{∣}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{→} \AgdaBound{⟦} \AgdaBound{A} \AgdaFunction{+T} \AgdaBound{B} \AgdaBound{⟧T} \AgdaSymbol{(}\AgdaFunction{coerce} \AgdaBound{⟦\_⟧C-β2} \AgdaSymbol{(}\AgdaBound{γ} \AgdaInductiveConstructor{,} \AgdaBound{v}\AgdaSymbol{))} \AgdaDatatype{≡} \<[54]%
\>[54]\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaBound{⟦} \AgdaBound{A} \AgdaBound{⟧T} \AgdaBound{γ}\<%
\\
\>[0]\AgdaIndent{2}{}\<[2]%
\>[2]\<%
\\
%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{semWk-S} \<[13]%
\>[13]\AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaBound{Δ} \AgdaBound{B}\AgdaSymbol{\}\{}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C}\AgdaSymbol{\}\{}\AgdaBound{v} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{⟦} \AgdaBound{B} \AgdaBound{⟧T} \AgdaBound{γ} \AgdaFunction{∣}\AgdaSymbol{\}}\<%
\\
\>[4]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{δ} \AgdaSymbol{:} \AgdaBound{Γ} \AgdaDatatype{⇒} \AgdaBound{Δ}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaBound{⟦} \AgdaBound{δ} \AgdaFunction{+S} \AgdaBound{B} \AgdaBound{⟧S} \<[41]%
\>[41]\<%
\\
\>[4]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{(}\AgdaFunction{coerce} \AgdaBound{⟦\_⟧C-β2} \AgdaSymbol{(}\AgdaBound{γ} \AgdaInductiveConstructor{,} \AgdaBound{v}\AgdaSymbol{))} \AgdaDatatype{≡} \AgdaBound{⟦} \AgdaBound{δ} \AgdaBound{⟧S} \AgdaBound{γ}\<%
\\
%
\\
\>[0]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{semWk-tm} \AgdaSymbol{:} \AgdaSymbol{∀} \AgdaSymbol{\{}\AgdaBound{Γ} \AgdaBound{A} \AgdaBound{B}\AgdaSymbol{\}(}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C}\AgdaSymbol{)(}\AgdaBound{v} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{⟦} \AgdaBound{B} \AgdaBound{⟧T} \AgdaBound{γ} \AgdaFunction{∣}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaIndent{13}{}\<[13]%
\>[13]\AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{a} \AgdaSymbol{:} \AgdaDatatype{Tm} \AgdaBound{A}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaFunction{subst} \AgdaFunction{∣\_∣} \AgdaSymbol{(}\AgdaBound{semWk-T} \AgdaBound{γ} \AgdaBound{v}\AgdaSymbol{)} \<[52]%
\>[52]\<%
\\
\>[13]\AgdaIndent{15}{}\<[15]%
\>[15]\AgdaSymbol{(}\AgdaBound{⟦} \AgdaBound{a} \AgdaFunction{+tm} \AgdaBound{B} \AgdaBound{⟧tm} \AgdaSymbol{(}\AgdaFunction{coerce} \AgdaBound{⟦\_⟧C-β2} \AgdaSymbol{(}\AgdaBound{γ} \AgdaInductiveConstructor{,} \AgdaBound{v}\AgdaSymbol{)))} \<[56]%
\>[56]\<%
\\
\>[15]\AgdaIndent{17}{}\<[17]%
\>[17]\AgdaDatatype{≡} \AgdaSymbol{(}\AgdaBound{⟦} \AgdaBound{a} \AgdaBound{⟧tm} \AgdaBound{γ}\AgdaSymbol{)}\<%
\\
\>\<\end{code}
Here we declare them as properties because they are essential for the computation laws of function $\AgdaField{π}$.

\begin{code}\>\<%
\\
\>[-2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{π-β1} \<[10]%
\>[10]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{A}\AgdaSymbol{\}(}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C}\AgdaSymbol{)(}\AgdaBound{v} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{⟦} \AgdaBound{A} \AgdaBound{⟧T} \AgdaBound{γ} \AgdaFunction{∣}\AgdaSymbol{)} \<[49]%
\>[49]\<%
\\
\>[0]\AgdaIndent{10}{}\<[10]%
\>[10]\AgdaSymbol{→} \AgdaFunction{subst} \AgdaFunction{∣\_∣} \AgdaSymbol{(}\AgdaBound{semWk-T} \AgdaBound{γ} \AgdaBound{v}\AgdaSymbol{)} \<[36]%
\>[36]\<%
\\
\>[10]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{(}\AgdaBound{π} \AgdaInductiveConstructor{v0} \AgdaSymbol{(}\AgdaFunction{coerce} \AgdaBound{⟦\_⟧C-β2} \AgdaSymbol{(}\AgdaBound{γ} \AgdaInductiveConstructor{,} \AgdaBound{v}\AgdaSymbol{)))} \AgdaDatatype{≡} \AgdaBound{v}\<%
\\
%
\\
\>[-2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{π-β2} \<[10]%
\>[10]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Γ} \AgdaBound{A} \AgdaBound{B}\AgdaSymbol{\}(}\AgdaBound{x} \AgdaSymbol{:} \AgdaDatatype{Var} \AgdaBound{A}\AgdaSymbol{)(}\AgdaBound{γ} \AgdaSymbol{:} \AgdaBound{⟦} \AgdaBound{Γ} \AgdaBound{⟧C}\AgdaSymbol{)(}\AgdaBound{v} \AgdaSymbol{:} \AgdaFunction{∣} \AgdaBound{⟦} \AgdaBound{B} \AgdaBound{⟧T} \AgdaBound{γ} \AgdaFunction{∣}\AgdaSymbol{)} \<[62]%
\>[62]\<%
\\
\>[0]\AgdaIndent{10}{}\<[10]%
\>[10]\AgdaSymbol{→} \AgdaFunction{subst} \AgdaFunction{∣\_∣} \AgdaSymbol{(}\AgdaBound{semWk-T} \AgdaBound{γ} \AgdaBound{v}\AgdaSymbol{)} \AgdaSymbol{(}\AgdaBound{π} \AgdaSymbol{(}\AgdaInductiveConstructor{vS} \AgdaSymbol{\{}\AgdaBound{Γ}\AgdaSymbol{\}} \AgdaSymbol{\{}\AgdaBound{A}\AgdaSymbol{\}} \AgdaSymbol{\{}\AgdaBound{B}\AgdaSymbol{\}} \AgdaBound{x}\AgdaSymbol{)} \<[58]%
\>[58]\<%
\\
\>[10]\AgdaIndent{12}{}\<[12]%
\>[12]\AgdaSymbol{(}\AgdaFunction{coerce} \AgdaBound{⟦\_⟧C-β2} \AgdaSymbol{(}\AgdaBound{γ} \AgdaInductiveConstructor{,} \AgdaBound{v}\AgdaSymbol{)))} \AgdaDatatype{≡} \AgdaBound{π} \AgdaBound{x} \AgdaBound{γ}\<%
\\
\>\<\end{code}
The only part of the semantics where we have any freedom is the interpretation of the coherence constants:

\begin{code}\>\<%
\\
\>[-2]\AgdaIndent{4}{}\<[4]%
\>[4]\AgdaField{⟦coh⟧} \<[11]%
\>[11]\AgdaSymbol{:} \AgdaSymbol{∀\{}\AgdaBound{Θ}\AgdaSymbol{\}} \AgdaSymbol{→} \AgdaDatatype{isContr} \AgdaBound{Θ} \AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{A} \AgdaSymbol{:} \AgdaDatatype{Ty} \AgdaBound{Θ}\AgdaSymbol{)} \<[43]%
\>[43]\<%
\\
\>[0]\AgdaIndent{11}{}\<[11]%
\>[11]\AgdaSymbol{→} \AgdaSymbol{(}\AgdaBound{θ} \AgdaSymbol{:} \AgdaBound{⟦} \AgdaBound{Θ} \AgdaBound{⟧C}\AgdaSymbol{)} \AgdaSymbol{→} \AgdaFunction{∣} \AgdaBound{⟦} \AgdaBound{A} \AgdaBound{⟧T} \AgdaBound{θ} \AgdaFunction{∣}\<%
\\
\>\<\end{code}
However, we also need to require that the coherence constants are well
behaved with respect to substitution which in turn relies on the interpretation
of all terms. To address this we state the required properties in a
redundant form because the correctness for any other part of the
syntax follows from the defining equations we have already
stated. There seems to be no way to avoid this.

If the underlying globular type is not a globular set, we need to add coherence laws, which is not very well understood. On the other hand, restricting ourselves to globular sets means that our prime example $\AgdaFunction{Idω}$ is not an instance anymore. We should still be able to construct non-trivial globular sets, e.g.\ by encoding basic topological notions and defining higher homotopies as in a classical framework. However, we do not currently know a simple definition of a globular set which is a weak $\omega$-groupoid. One possibility would be to use the syntax of type theory with equality types. Indeed, we believe that this would be an alternative way to formalize weak $\omega$-groupoids.

\section{Related work}

The groupoid interpretation of \mltt was first proposed to Hofmann and Streicher \cite{MR1686862}.  Sozeau and Tabareau \cite{gitt} have formalised it in Coq. They have also considered to generalise their definitions to $\omega$-groupoids in the future. Warren \cite{Warren} has shown an interpretation of Type Theory using \emph{strict} $\omega$-groupoids.  Lumsdaine \cite{DBLP:journals/corr/abs-0812-0409}, van den Berg and Garner \cite{van2011types} have shown that $\J$ eliminator gives rise to a weak $\omega$-groupoid, van den Berg and Garner have proved that that every type is a weak $\omega$-groupoid.
Altenkirch and Ryp\'{a}\v{c}ek \cite{txa:csl} have proposed a syntactic formalisation of \wog in Type Theory and a simplification of it has been suggested by Brunerie \cite{gb:wog}.


\section{Summary}

In this chapter, we have introduced an implementation of \wog following Brunerie's suggestion. Briefly speaking, we defined the syntax of the type theory \tig, then a weak $\omega$-groupoid is a globular set with the interpretation of the syntax. To overcome some technical problems, we used heterogeneous equality for terms, some auxiliary functions and loop context in all implementation. We constructed the identity morphisms and verified some groupoid laws in the syntactic framework. The suspensions for all sorts of objects were also defined for other later constructions.
In the future, we would like to formalise a proof of that $\AgdaFunction{Idω}$ is a weak $\omega$-groupoid. As Altenkirch suggests, we can potentially solve the problem that our definition of  $\AgdaFunction{Idω}$ is not a globular set by using the approach discussed in \cite{CoherenceProblem}. Briefly speaking, we can define a universe with extensional equality, and use Agda's propositional equality as strict equality so that we can define $\AgdaFunction{Idω}$ as a globular set in this universe.
Finally the most challenge task would be to model Type Theory with weak $\omega$-groupoids and to eliminate the univalence axiom.
